<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Meta8 Showdown: Brawl</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 3em;
            color: #00d4ff;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            color: #aaa;
        }

        /* Boost Assignment Screen */
        .boost-setup-screen {
            display: none;
            max-width: 1100px;
            margin: 0 auto;
        }

        .boost-setup-screen.show {
            display: block;
        }

        .setup-title {
            font-size: 2.5em;
            color: #00d4ff;
            text-align: center;
            margin-bottom: 30px;
        }

        .player-boost-list {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            border: 2px solid rgba(0, 212, 255, 0.3);
            margin-bottom: 30px;
        }

        .player-boost-item {
            display: grid;
            grid-template-columns: 80px 150px 1fr 1fr 150px;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            gap: 15px;
        }

        .player-boost-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;          /* hide zoom overflow */
            border: 3px solid #ffffff; /* gang color will override via inline style */
            background: #222;
        }

        /* NFT image inside boost setup avatar (zoomed on face) */
        .player-boost-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* zoom & move “camera” up towards face */
            transform: scale(6);
            transform-origin: 48% 20%;
            display: block;
            border-radius: 50%;
        }

        .player-boost-name {
            font-size: 1.1em;
        }

        .boost-column {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .boost-label {
            font-size: 0.85em;
            color: #aaa;
            margin-bottom: 3px;
        }

        .boost-select {
            padding: 8px 12px;
            font-size: 0.95em;
            border-radius: 5px;
            border: 2px solid rgba(0, 212, 255, 0.5);
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            cursor: pointer;
            width: 100%;
        }

        .boost-select:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .boost-select.secondary {
            border-color: rgba(255, 215, 0, 0.5);
        }

        .boost-select.secondary:focus {
            border-color: #ffd700;
        }

        .setup-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .setup-button {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
        }

        .setup-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 212, 255, 0.5);
        }

        .setup-button.secondary {
            background: linear-gradient(135deg, #6c5ce7 0%, #5f4dd1 100%);
        }

        /* Game Area */
        .game-area {
            display: none;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            margin-bottom: 30px;
        }

        .game-area.show {
            display: grid;
        }

        .bracket-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            border: 2px solid rgba(0, 212, 255, 0.3);
        }

        .dice-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            border: 2px solid rgba(0, 212, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .round-title {
            font-size: 2em;
            color: #00d4ff;
            margin-bottom: 20px;
            text-align: center;
        }

        .match {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .match.active {
            border-color: #00d4ff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .match.completed {
            opacity: 0.6;
        }

        .player {
            display: flex;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            position: relative;
        }

        .player.winner {
            background: rgba(0, 212, 255, 0.2);
            border: 2px solid #00d4ff;
        }

        .player.loser {
            opacity: 0.5;
        }

        .avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            overflow: hidden;
            border: 3px solid #ffffff; /* gang color via inline style in JS */
            background: #222;
        }

        /* NFT image inside player avatar (zoomed on face) */
        .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scale(6);
            transform-origin: 48% 20%;
            display: block;
            border-radius: 50%;
        }

        .player-name {
            flex: 1;
            font-size: 1.2em;
        }

        .player-boosts {
            display: flex;
            gap: 5px;
            margin-right: 10px;
            flex-wrap: wrap;
        }

        .boost-badge {
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.75em;
            font-weight: bold;
            border: 1px solid;
        }

        /* Boost color variants */
        .boost-badge.boost-yellow {
            background: rgba(245, 158, 11, 0.2);
            border-color: #ffd700;
            color: #ffd700;
        }

        .boost-badge.boost-green {
            background: rgba(16, 185, 129, 0.2);
            border-color: #10b981;
            color: #10b981;
        }

        .boost-badge.boost-purple {
            background: rgba(168, 85, 247, 0.2);
            border-color: #a855f7;
            color: #a855f7;
        }

        .boost-badge.used {
            opacity: 0.3;
            text-decoration: line-through;
        }

        .boost-badge.inactive {
            opacity: 0.4;
            border-style: dashed;
        }

        .boost-badge.inactive:hover::after,
        .boost-badge.inactive:hover::before {
            opacity: 1 !important;
        }

        .boost-badge.stolen {
            border-color: #ff0000;
            color: #ff0000;
            background: rgba(255, 0, 0, 0.2);
        }

        .score-dots {
            display: flex;
            gap: 5px;
        }

        .dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #666;
        }

        .dot.win {
            background: #00ff00;
            border-color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .dot.loss {
            background: #ff0000;
            border-color: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .dot.tie {
            background: #ffff00;
            border-color: #ffff00;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
        }

        .dice-container {
            display: flex;
            gap: 30px;
            margin: 30px 0;
        }

        .die {
            width: 80px;
            height: 80px;
            background: #fff;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            color: #000;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s;
        }

        .die.rolling {
            animation: roll 0.5s ease-in-out;
        }

        @keyframes roll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(0.9); }
            75% { transform: rotate(270deg) scale(1.1); }
        }

        .dice-labels {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .dice-label {
            width: 80px;
            text-align: center;
            color: #00d4ff;
        }

        .roll-button {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
            margin-top: 20px;
        }

        .roll-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 212, 255, 0.5);
        }

        .roll-button:active {
            transform: translateY(0);
        }

        .roll-button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .result-message {
            font-size: 1.3em;
            margin-top: 20px;
            text-align: center;
            min-height: 30px;
            color: #00d4ff;
        }

        .reset-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .reset-button {
            background: linear-gradient(135deg, #6c5ce7 0%, #5f4dd1 100%);
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 0.95em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 3px 10px rgba(108, 92, 231, 0.3);
            white-space: nowrap;
        }

        .reset-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.5);
        }

        .reset-button:active {
            transform: translateY(0);
        }

        .continue-button {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
            margin-top: 20px;
            display: none;
        }

        .continue-button.show {
            display: block;
        }

        .continue-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(16, 185, 129, 0.5);
        }

        .continue-button:active {
            transform: translateY(0);
        }

        .boost-notification {
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 10px 20px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: bold;
            text-align: center;
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .winner-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .winner-screen.show {
            display: flex;
        }

        .winner-content {
            text-align: center;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .winner-title {
            font-size: 4em;
            color: #00d4ff;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
            margin-bottom: 20px;
        }

        .winner-name {
            font-size: 3em;
            color: #fff;
            margin-bottom: 30px;
        }

        .restart-button {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
        }

        .restart-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 212, 255, 0.5);
        }

        .match-info {
            text-align: center;
            font-size: 1.1em;
            color: #aaa;
            margin-bottom: 20px;
        }

        .sudden-death-indicator {
            color: #ff0000;
            font-weight: bold;
            font-size: 1.3em;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .match.interference {
            border-color: #ff6b00;
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.4);
        }

        /* Gang Takeover Effects */
        .match.gang-takeover {
            animation: gangTakeoverPulse 2s ease-in-out infinite;
        }

        @keyframes gangTakeoverPulse {
            0%, 100% {
                box-shadow: 0 0 30px var(--gang-color);
            }
            50% {
                box-shadow: 0 0 60px var(--gang-color), 0 0 90px var(--gang-color);
            }
        }

        .gang-takeover-notice {
            padding: 12px 20px;
            margin-bottom: 15px;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 1.1em;
            animation: gangTakeoverFlash 1.5s ease-in-out;
        }

        @keyframes gangTakeoverFlash {
            0%, 100% { 
                transform: scale(1);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.05);
                filter: brightness(1.3);
            }
        }

        .interference-notice {
            padding: 8px 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
            font-size: 0.9em;
        }

        .interference-notice.decryptor {
            background: rgba(255, 107, 0, 0.2);
            border: 2px solid #ff6b00;
            color: #ff6b00;
        }

        .interference-notice.storm {
            background: rgba(138, 43, 226, 0.2);
            border: 2px solid #8a2be2;
            color: #8a2be2;
        }

        @media (max-width: 1200px) {
            .game-area {
                grid-template-columns: 1fr;
            }

            .player-boost-item {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }
    
        /* ============================================ */
        /* TEST MODE PANEL */
        /* ============================================ */
        #testModePanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 25px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            display: none;
        }

        #testModePanel.active {
            display: block;
        }

        /* ============================================ */
        /* ROLL HISTORY PANEL */
        /* ============================================ */
        #rollHistoryPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid #3498db;
            border-radius: 15px;
            padding: 25px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 0 30px rgba(52, 152, 219, 0.5);
            display: none;
        }

        #rollHistoryPanel.active {
            display: block;
        }

        .roll-history-title {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #3498db;
        }

        .roll-history-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .roll-history-item {
            background: rgba(30, 40, 60, 0.6);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 12px 15px;
        }

        .roll-history-header {
            font-size: 14px;
            color: #3498db;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .roll-history-players {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .roll-history-player {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 15px;
        }

        .roll-history-result {
            font-size: 28px;
            font-weight: bold;
            color: #fff;
        }

        .roll-history-vs {
            color: #7f8c8d;
            font-size: 14px;
            font-weight: bold;
        }

        .roll-history-outcome {
            text-align: center;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(52, 152, 219, 0.2);
            font-size: 13px;
            color: #95a5a6;
        }

        .roll-history-winner {
            color: #2ecc71;
            font-weight: bold;
        }

        .roll-history-tie {
            color: #f39c12;
            font-weight: bold;
        }

        #testModePanel h2 {
            color: #00ffff;
            margin-top: 0;
            text-align: center;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .test-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .test-section h3 {
            color: #ffd700;
            margin-top: 0;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .test-control {
            margin-bottom: 10px;
        }

        .test-control label {
            display: block;
            color: #fff;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .test-control select,
        .test-control input {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: #fff;
            font-size: 14px;
        }

        .test-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
            margin-top: 5px;
            transition: all 0.3s;
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .test-button.danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .test-button.success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        #rollHistoryToggle {
            position: fixed;
            top: 10px;
            right: 180px;
            background: rgba(52, 152, 219, 0.2);
            border: 2px solid #3498db;
            color: #3498db;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            z-index: 9999;
            transition: all 0.3s;
        }

        #rollHistoryToggle:hover {
            background: rgba(52, 152, 219, 0.4);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.6);
        }

        #rollHistoryToggle.active {
            background: rgba(52, 152, 219, 0.5);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.8);
        }

        #testModeToggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            z-index: 9999;
            transition: all 0.3s;
        }

        #testModeToggle:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }

    
        /* Cosmic Storm - Disabled Boosts */
        .boost-badge.disabled {
            opacity: 0.4;
            text-decoration: line-through;
            filter: grayscale(100%);
        }

        .boost-badge.disabled::after {
            content: ' ⚡';
            color: #9333ea;
            font-size: 0.8em;
        }

        /* Tooltip Styles - Fixed Positioning */
        .boost-badge {
            position: relative;
            cursor: help;
        }


        
        /* ========================================= */
        /* CYBERPUNK/NEON ENHANCEMENTS - V2 */
        /* ========================================= */

        /* Neon glow effects on key elements */
        h1 {
            animation: neonPulse 3s ease-in-out infinite;
        }

        @keyframes neonPulse {
            0%, 100% {
                text-shadow: 0 0 20px rgba(0, 212, 255, 0.5),
                             0 0 40px rgba(0, 212, 255, 0.3);
            }
            50% {
                text-shadow: 0 0 30px rgba(0, 212, 255, 0.8),
                             0 0 60px rgba(0, 212, 255, 0.5),
                             0 0 80px rgba(0, 212, 255, 0.3);
            }
        }

        /* Glowing borders for game areas */
        .boost-setup-screen, .game-area, .bracket-section, .dice-section {
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.1);
            transition: box-shadow 0.3s ease;
        }

        .boost-setup-screen:hover, .bracket-section:hover, .dice-section:hover {
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        /* Scanline effect overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.05),
                rgba(0, 0, 0, 0.05) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1;
            opacity: 0.3;
        }

        /* Animated background gradient */
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #1a1a2e 100%);
            background-size: 200% 200%;
            animation: gradientShift 15s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Neon button effects */
        .setup-button, .roll-button, .restart-button, .test-button {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .setup-button::before, .roll-button::before, .restart-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .setup-button:hover::before, .roll-button:hover::before, .restart-button:hover::before {
            left: 100%;
        }

        /* Boost badge glow animations */
        .boost-badge {
            transition: all 0.3s ease;
            position: relative;
        }

        .boost-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px currentColor;
        }

        /* Active match pulsing border */
        .match.active {
            animation: activePulse 2s ease-in-out infinite;
        }

        @keyframes activePulse {
            0%, 100% {
                border-color: #00d4ff;
                box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
            }
            50% {
                border-color: #00ffff;
                box-shadow: 0 0 35px rgba(0, 212, 255, 0.6);
            }
        }

        /* Dice glow effect */
        .die {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3),
                        0 0 20px rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .die:hover {
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3);
        }

        /* Winner screen effects */
        .winner-title {
            animation: championGlow 1.5s ease-in-out infinite;
        }

        @keyframes championGlow {
            0%, 100% {
                text-shadow: 0 0 30px rgba(0, 212, 255, 0.8),
                             0 0 60px rgba(0, 212, 255, 0.5);
            }
            50% {
                text-shadow: 0 0 50px rgba(0, 212, 255, 1),
                             0 0 90px rgba(0, 212, 255, 0.7),
                             0 0 120px rgba(0, 212, 255, 0.4);
            }
        }

        /* Enhanced notification banner */
        .boost-notification {
            animation: notificationSlide 0.5s ease, notificationGlow 0.5s ease;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        @keyframes notificationSlide {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes notificationGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            }
            50% {
                box-shadow: 0 0 35px rgba(255, 215, 0, 0.7);
            }
        }

        /* ========================================= */
        /* BOOST ACTIVATION ANIMATIONS */
        /* ========================================= */

        /* NosDemon Animation - Lightning Strike */
        @keyframes nosdemonActivate {
            0% { transform: scale(1); opacity: 1; }
            25% { transform: scale(1.2) rotate(5deg); opacity: 0.8; }
            50% { transform: scale(1.1) rotate(-5deg); opacity: 1; }
            75% { transform: scale(1.15) rotate(3deg); opacity: 0.9; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .boost-activate-nosdemon {
            animation: nosdemonActivate 0.6s ease, glowPulse 0.6s ease;
            box-shadow: 0 0 30px #ffd700, 0 0 60px #ffd700;
        }

        /* Revive Animation - Resurrection Pulse */
        @keyframes reviveActivate {
            0% { transform: scale(0.8); opacity: 0; filter: brightness(2); }
            50% { transform: scale(1.3); opacity: 1; filter: brightness(1.5); }
            100% { transform: scale(1); opacity: 1; filter: brightness(1); }
        }

        .boost-activate-revive {
            animation: reviveActivate 0.8s ease;
            box-shadow: 0 0 40px #10b981, 0 0 80px #10b981;
        }

        /* Thief Animation - Steal Flash */
        @keyframes thiefActivate {
            0%, 100% { transform: translateX(0); opacity: 1; }
            20% { transform: translateX(-10px) scale(1.1); opacity: 0.7; }
            40% { transform: translateX(10px) scale(0.9); opacity: 0.9; }
            60% { transform: translateX(-5px) scale(1.05); opacity: 0.8; }
            80% { transform: translateX(5px) scale(0.95); opacity: 1; }
        }

        .boost-activate-thief {
            animation: thiefActivate 0.7s ease;
            box-shadow: 0 0 35px #ff0000, 0 0 70px #ff0000;
        }

        /* Guardian Animation - Shield Expand */
        @keyframes guardianActivate {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
            50% { transform: scale(1.15); box-shadow: 0 0 0 20px rgba(16, 185, 129, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 40px rgba(16, 185, 129, 0); }
        }

        .boost-activate-guardian {
            animation: guardianActivate 0.8s ease;
        }

        /* Brawler Animation - Combat Strike */
        @keyframes brawlerActivate {
            0% { transform: translateX(0) rotate(0deg); }
            20% { transform: translateX(-15px) rotate(-10deg); }
            40% { transform: translateX(15px) rotate(10deg); }
            60% { transform: translateX(-10px) rotate(-5deg); }
            80% { transform: translateX(10px) rotate(5deg); }
            100% { transform: translateX(0) rotate(0deg); }
        }

        .boost-activate-brawler {
            animation: brawlerActivate 0.6s ease;
            box-shadow: 0 0 30px #f59e0b, 0 0 60px #f59e0b;
        }

        /* Scavenger Animation - Collect Spin */
        @keyframes scavengerActivate {
            0% { transform: rotate(0deg) scale(1); opacity: 1; }
            50% { transform: rotate(360deg) scale(1.2); opacity: 0.8; }
            100% { transform: rotate(720deg) scale(1); opacity: 1; }
        }

        .boost-activate-scavenger {
            animation: scavengerActivate 1s ease;
            box-shadow: 0 0 35px #a855f7, 0 0 70px #a855f7;
        }

        /* Double Play Animation - Echo Effect */
        @keyframes doubleplayActivate {
            0% { transform: scale(1); opacity: 1; }
            25% { transform: scale(1.1); opacity: 0.8; }
            50% { transform: scale(0.95); opacity: 1; }
            75% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .boost-activate-doubleplay {
            animation: doubleplayActivate 0.8s ease;
            box-shadow: 0 0 30px #10b981, 0 0 60px #10b981;
        }

        /* Generic glow pulse */
        @keyframes glowPulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }

        /* ==== */
        /* INTERFERENCE ANIMATIONS */
        /* ==== */

        /* Cosmic Storm - Screen Flash & Shake */
        @keyframes cosmicStormFlash {
            0%, 100% { 
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                transform: translateX(0);
            }
            10% { 
                background: linear-gradient(135deg, #8a2be2 0%, #4b0082 100%);
                transform: translateX(-5px);
            }
            20% { 
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                transform: translateX(5px);
            }
            30% { 
                background: linear-gradient(135deg, #8a2be2 0%, #4b0082 100%);
                transform: translateX(-3px);
            }
            40% { 
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                transform: translateX(3px);
            }
            50% { 
                background: linear-gradient(135deg, #8a2be2 0%, #4b0082 100%);
                transform: translateX(0);
            }
        }

        .cosmic-storm-active {
            animation: cosmicStormFlash 1.5s ease-in-out;
        }

        /* Decryptor - Match Box Shake & Glitch */
        @keyframes decryptorGlitch {
            0%, 100% { 
                transform: translateX(0) skew(0deg);
                filter: hue-rotate(0deg);
            }
            10% { 
                transform: translateX(-10px) skew(-2deg);
                filter: hue-rotate(90deg);
            }
            20% { 
                transform: translateX(10px) skew(2deg);
                filter: hue-rotate(180deg);
            }
            30% { 
                transform: translateX(-8px) skew(-1deg);
                filter: hue-rotate(270deg);
            }
            40% { 
                transform: translateX(8px) skew(1deg);
                filter: hue-rotate(0deg);
            }
            50% { 
                transform: translateX(-5px) skew(-0.5deg);
                filter: hue-rotate(90deg);
            }
            60% { 
                transform: translateX(5px) skew(0.5deg);
                filter: hue-rotate(180deg);
            }
            70% { 
                transform: translateX(-3px) skew(0deg);
                filter: hue-rotate(270deg);
            }
            80% { 
                transform: translateX(3px) skew(0deg);
                filter: hue-rotate(0deg);
            }
            90% { 
                transform: translateX(-1px) skew(0deg);
                filter: hue-rotate(0deg);
            }
        }

        .decryptor-active {
            animation: decryptorGlitch 1.2s ease-in-out;
        }

        /* Pulsing border for interference matches */
        @keyframes interferencePulse {
            0%, 100% {
                border-color: #ff6b00;
                box-shadow: 0 0 20px rgba(255, 107, 0, 0.4);
            }
            50% {
                border-color: #ff9500;
                box-shadow: 0 0 40px rgba(255, 107, 0, 0.8);
            }
        }

        .match.interference {
            animation: interferencePulse 2s ease-in-out infinite;
        }

        /* ========================================= */
        /* ENHANCED NOTIFICATION SYSTEM */
        /* ========================================= */

        #boostNotificationContainer {
            position: fixed;
            top: 100px;
            right: 20px;
            z-index: 9998;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            max-width: 400px;
        }

        .boost-notification-banner {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95) 0%, rgba(255, 165, 0, 0.95) 100%);
            border: 3px solid #ffd700;
            border-radius: 12px;
            padding: 15px 20px;
            box-shadow: 0 5px 25px rgba(255, 215, 0, 0.5),
                        0 0 40px rgba(255, 215, 0, 0.3);
            font-weight: bold;
            font-size: 1.1em;
            color: #000;
            animation: bannerSlideIn 0.5s ease, bannerGlow 2s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }

        .boost-notification-banner::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
            animation: bannerShine 2s ease-in-out infinite;
        }

        @keyframes bannerSlideIn {
            from {
                transform: translateX(120%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes bannerGlow {
            0%, 100% {
                box-shadow: 0 5px 25px rgba(255, 215, 0, 0.5),
                            0 0 40px rgba(255, 215, 0, 0.3);
            }
            50% {
                box-shadow: 0 5px 35px rgba(255, 215, 0, 0.8),
                            0 0 60px rgba(255, 215, 0, 0.5);
            }
        }

        @keyframes bannerShine {
            0% { left: -100%; }
            50%, 100% { left: 200%; }
        }

        .boost-notification-banner.slide-out {
            animation: bannerSlideOut 0.5s ease forwards;
        }

        @keyframes bannerSlideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(120%);
                opacity: 0;
            }
        }

        /* ========================================= */
        /* TOOLTIP SYSTEM */
        /* ========================================= */

        .tooltip {
            position: fixed;
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.98) 0%, rgba(30, 30, 50, 0.98) 100%);
            border: 2px solid #00d4ff;
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            font-size: 0.9em;
            z-index: 10001;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4),
                        0 0 30px rgba(0, 212, 255, 0.2);
            max-width: 250px;
            white-space: normal;
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid #00d4ff;
        }

        .tooltip-title {
            font-weight: bold;
            color: #00d4ff;
            margin-bottom: 5px;
            font-size: 1.05em;
        }

        .tooltip-description {
            color: #ccc;
            line-height: 1.4;
        }

        /* Make boost badges tooltippable */
        .boost-badge {
            cursor: help;
        }

        /* Sound toggle button */
        #soundToggle {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 212, 255, 0.2);
            border: 2px solid #00d4ff;
            color: #00d4ff;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            z-index: 9999;
            transition: all 0.3s;
        }

        #soundToggle:hover {
            background: rgba(0, 212, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.6);
        }

        #soundToggle.muted {
            background: rgba(255, 0, 0, 0.2);
            border-color: #ff0000;
            color: #ff0000;
        }

        /* ==== */
        /* CUSTOM PLAYERS POPUP */
        /* ==== */

        #customPlayersPopup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        #customPlayersPopup.show {
            display: flex;
        }

        .custom-players-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #00d4ff;
            border-radius: 15px;
            padding: 30px;
            max-width: 900px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.6);
        }

        .custom-players-title {
            font-size: 2em;
            color: #00d4ff;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .custom-player-input {
            display: grid;
            grid-template-columns: 45px 60px 1fr 120px 200px;
            gap: 10px;
            align-items: center;
            margin-bottom: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 4px solid transparent;
        }

        .custom-player-gang-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: bold;
            text-align: center;
            border: 2px solid;
            background: rgba(0, 0, 0, 0.3);
        }

        .custom-player-label {
            font-weight: bold;
            color: #00d4ff;
        }

        .custom-player-input input {
            padding: 8px 12px;
            font-size: 1em;
            border-radius: 5px;
            border: 2px solid rgba(0, 212, 255, 0.5);
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
        }

        .custom-player-input input:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .custom-player-input input.error {
            border-color: #ff0000;
        }

        .custom-player-icon {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid;
            background: #222;
        }

        .custom-player-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scale(6);
            transform-origin: 48% 20%;
            display: block;
            border-radius: 50%;
        }

        .custom-players-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        .custom-players-button {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #fff;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
        }

        .custom-players-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 212, 255, 0.5);
        }

        .custom-players-button.cancel {
            background: linear-gradient(135deg, #6c5ce7 0%, #5f4dd1 100%);
        }

        .error-message {
            color: #ff6b6b;
            font-size: 0.9em;
            text-align: center;
            margin-top: 10px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        /* ==== */
        /* BRACKET VISUALIZATION */
        /* ==== */

        .bracket-view-toggle {
            text-align: center;
            margin-bottom: 20px;
        }

        .bracket-toggle-btn {
            background: linear-gradient(135deg, #6c5ce7 0%, #5f4dd1 100%);
            color: #fff;
            border: none;
            padding: 10px 25px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 3px 10px rgba(108, 92, 231, 0.3);
            margin: 0 5px;
        }

        .bracket-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.5);
        }

        .bracket-toggle-btn.active {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.5);
        }

        .full-bracket-container {
            display: none;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            border: 2px solid rgba(0, 212, 255, 0.3);
            overflow-x: auto;
        }

        .full-bracket-container.show {
            display: block;
        }

        .bracket-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 40px;
            min-width: 900px;
        }

        .bracket-round {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .bracket-round-title {
            font-size: 1.5em;
            color: #00d4ff;
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .bracket-match-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .bracket-match-card.completed {
            border-color: rgba(0, 212, 255, 0.5);
        }

        .bracket-match-card.active {
            border-color: #00d4ff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
            animation: activePulse 2s ease-in-out infinite;
        }

        .bracket-match-card.pending {
            opacity: 0.6;
        }

        .bracket-player-row {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .bracket-player-row.winner {
            background: rgba(0, 212, 255, 0.2);
            border: 2px solid #00d4ff;
        }

        .bracket-player-row.loser {
            opacity: 0.5;
        }

        .bracket-player-row.pending {
            background: rgba(255, 255, 255, 0.02);
            font-style: italic;
            color: #888;
        }

        .bracket-avatar-small {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            overflow: hidden;
            border: 3px solid #ffffff;
            background: #222;
        }

        /* NFT image inside bracket avatar (zoomed) */
        .bracket-avatar-small img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scale(6);
            transform-origin: 48% 20%;
            display: block;
            border-radius: 50%;
        }

        .bracket-player-info {
            flex: 1;
        }

        .bracket-player-name {
            font-size: 1em;
            font-weight: bold;
        }

        .bracket-player-score {
            font-size: 0.85em;
            color: #aaa;
        }

        .bracket-match-score {
            font-size: 1.2em;
            font-weight: bold;
            color: #00d4ff;
            margin-left: 10px;
        }

        .bracket-connector {
            position: absolute;
            right: -40px;
            top: 50%;
            width: 40px;
            height: 2px;
            background: rgba(0, 212, 255, 0.3);
            transform: translateY(-50%);
        }

        .bracket-match-card.completed .bracket-connector {
            background: rgba(0, 212, 255, 0.6);
        }

        /* Responsive bracket */
        @media (max-width: 1200px) {
            .bracket-grid {
                grid-template-columns: 1fr;
                gap: 30px;
                min-width: auto;
            }
            
            .bracket-connector {
                display: none;
            }
        }
        /* ==== */
        /* KEYBOARD SHORTCUTS HELP OVERLAY */
        /* ==== */

        #keyboardHelpOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10002;
            backdrop-filter: blur(5px);
        }

        #keyboardHelpOverlay.show {
            display: flex;
        }

        .keyboard-help-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #00d4ff;
            border-radius: 15px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.6);
            animation: helpSlideIn 0.3s ease;
        }

        @keyframes helpSlideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .keyboard-help-title {
            font-size: 2.2em;
            color: #00d4ff;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .keyboard-help-section {
            margin-bottom: 25px;
        }

        .keyboard-help-section-title {
            font-size: 1.3em;
            color: #ffd700;
            margin-bottom: 15px;
            font-weight: bold;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
            padding-bottom: 8px;
        }

        .keyboard-shortcut-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(0, 212, 255, 0.2);
            transition: all 0.3s;
        }

        .keyboard-shortcut-item:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: rgba(0, 212, 255, 0.5);
            transform: translateX(5px);
        }

        .keyboard-key {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid #00d4ff;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 1.1em;
            font-weight: bold;
            color: #00d4ff;
            min-width: 50px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            margin-right: 20px;
        }

        .keyboard-description {
            flex: 1;
            color: #ccc;
            font-size: 1em;
            line-height: 1.4;
        }

        .keyboard-help-close {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #fff;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
            display: block;
            margin: 30px auto 0;
        }

        .keyboard-help-close:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 212, 255, 0.5);
        }

        .keyboard-help-footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #888;
            font-size: 0.9em;
        }

        /* ==== */
        /* STATS TRACKING PANEL */
        /* ==== */

        #statsToggle {
            position: fixed;
            top: 10px;
            right: 350px;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            z-index: 9999;
            transition: all 0.3s;
        }

        #statsToggle:hover {
            background: rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }

        #statsToggle.active {
            background: rgba(255, 215, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        #statsPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 25px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            display: none;
        }

        #statsPanel.active {
            display: block;
        }

        .stats-title {
            font-size: 28px;
            font-weight: bold;
            color: #ffd700;
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }

        .stats-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .stats-section-title {
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s;
        }

        .stat-item:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.5);
            transform: translateY(-2px);
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .stat-label {
            font-size: 14px;
            color: #ccc;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .player-stats-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .player-stat-item {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            padding: 12px 15px;
            transition: all 0.3s;
        }

        .player-stat-item:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.5);
            transform: translateX(5px);
        }

        .player-stat-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            overflow: hidden;
            border: 3px solid #ffffff;
            background: #222;
        }

        /* NFT image inside stats avatar (zoomed) */
        .player-stat-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scale(6);
            transform-origin: 48% 20%;
            display: block;
            border-radius: 50%;
        }

        .player-stat-info {
            flex: 1;
        }

        .player-stat-name {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 3px;
        }

        .player-stat-details {
            font-size: 13px;
            color: #aaa;
        }

        .player-stat-wins {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            margin-left: 15px;
        }

        .stats-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        .stats-button {
            background: linear-gradient(135deg, #ffd700 0%, #ffb700 100%);
            color: #000;
            border: none;
            padding: 12px 30px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
        }

        .stats-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(255, 215, 0, 0.5);
        }

        .stats-button.danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: #fff;
        }

        /* ==== */
        /* COMPREHENSIVE MOBILE RESPONSIVE STYLES */
        /* ==== */

        /* Tablet Landscape - 1200px and below */
        @media (max-width: 1200px) {
            h1 {
                font-size: 2em;
            }
            
            .splash-title {
                font-size: 2em;
            }
            
            .splash-nft-container {
                width: 250px;
                height: 250px;
            }
            
            /* Reduce notification banner size */
            #boostNotificationContainer {
                max-width: 300px;
                font-size: 0.95em;
            }
        }

        /* Tablet Portrait / Large Phone - 768px and below */
        @media (max-width: 768px) {
            /* Safe area padding for Safari */
            body {
                padding: env(safe-area-inset-top, 20px) env(safe-area-inset-right, 20px) env(safe-area-inset-bottom, 20px) env(safe-area-inset-left, 20px);
                -webkit-overflow-scrolling: touch;
            }
            
            /* Reduce overall spacing */
            header {
                margin-bottom: 15px;
            }
            
            h1 {
                font-size: 1.5em;
                margin-bottom: 5px;
            }
            
            .subtitle {
                font-size: 1em;
            }
            
            /* Boost Setup Screen */
            .setup-title {
                font-size: 1.8em;
                margin-bottom: 20px;
            }
            
            .player-boost-list {
                padding: 15px;
                margin-bottom: 20px;
            }
            
            .player-boost-item {
                grid-template-columns: 1fr;
                padding: 10px;
                margin: 5px 0;
                gap: 8px;
            }
            
            .player-boost-avatar {
                width: 45px;
                height: 45px;
            }
            
            .player-boost-name {
                font-size: 0.95em;
            }
            
            .boost-select {
                padding: 6px 10px;
                font-size: 0.85em;
            }
            
            .setup-buttons {
                flex-direction: column;
                gap: 10px;
                padding-bottom: env(safe-area-inset-bottom, 90px);
            }
            
            .setup-button {
                padding: 12px 30px;
                font-size: 1.1em;
                width: 100%;
            }
            
            /* Game Area - CRITICAL FIX */
            .game-area {
                grid-template-columns: 1fr;
                gap: 15px;
                margin-bottom: env(safe-area-inset-bottom, 90px);
            }
            
            .bracket-section {
                padding: 15px;
                order: 2;
            }
            
            .dice-section {
                padding: 15px;
                order: 1;
                position: sticky;
                top: env(safe-area-inset-top, 10px);
                z-index: 100;
                background: rgba(26, 26, 46, 0.95);
                backdrop-filter: blur(10px);
            }
            
            /* Match cards */
            .match {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .round-title {
                font-size: 1.4em;
                margin-bottom: 12px;
            }
            
            /* Player cards - smaller */
            .player {
                padding: 10px;
                margin: 6px 0;
            }
            
            .avatar {
                width: 45px;
                height: 45px;
                margin-right: 10px;
            }
            
            .player-name {
                font-size: 1em;
            }
            
            /* Boost badges - smaller */
            .boost-badge {
                padding: 2px 6px;
                font-size: 0.65em;
            }
            
            .player-boosts {
                gap: 3px;
            }
            
            /* Score dots - smaller */
            .dot {
                width: 15px;
                height: 15px;
            }
            
            /* Dice area */
            .dice-container {
                gap: 20px;
                margin: 15px 0;
            }
            
            .die {
                width: 60px;
                height: 60px;
                font-size: 2em;
            }
            
            .dice-labels {
                gap: 20px;
                margin-bottom: 12px;
                font-size: 1em;
            }
            
            .dice-label {
                width: 60px;
            }
            
            .match-info {
                font-size: 0.95em;
                margin-bottom: 12px;
            }
            
            /* Buttons */
            .roll-button {
                padding: 12px 30px;
                font-size: 1.1em;
                margin-top: 12px;
            }
            
            .continue-button {
                padding: 12px 30px;
                font-size: 1.1em;
                margin-top: 12px;
            }
            
            .reset-buttons {
                gap: 6px;
                margin-top: 12px;
            }
            
            .reset-button {
                padding: 7px 12px;
                font-size: 0.8em;
            }
            
            .result-message {
                font-size: 1.1em;
                margin-top: 12px;
            }
            
            /* Top header buttons - stack and resize */
            #soundToggle {
                top: env(safe-area-inset-top, 10px);
                left: 10px;
                padding: 6px 10px;
                font-size: 10px;
            }
            
            #testModeToggle {
                top: env(safe-area-inset-top, 10px);
                right: 10px;
                padding: 6px 10px;
                font-size: 10px;
            }
            
            #rollHistoryToggle {
                top: env(safe-area-inset-top, 50px);
                right: 10px;
                padding: 6px 10px;
                font-size: 10px;
            }
            
            #statsToggle {
                top: env(safe-area-inset-top, 90px);
                right: 10px;
                padding: 6px 10px;
                font-size: 10px;
            }
            
            /* Notifications */
            #boostNotificationContainer {
                top: env(safe-area-inset-top, 130px);
                right: 10px;
                max-width: 250px;
            }
            
            .boost-notification-banner {
                padding: 10px 12px;
                font-size: 0.9em;
            }
            
            /* Modals */
            #customPlayersPopup .custom-players-content {
                padding: 20px;
                max-height: 80vh;
            }
            
            .custom-players-title {
                font-size: 1.5em;
                margin-bottom: 15px;
            }
            
            .custom-player-input {
                grid-template-columns: 1fr;
                padding: 8px;
                gap: 6px;
            }
            
            .custom-player-icon {
                width: 35px;
                height: 35px;
            }
            
            .custom-player-input input {
                padding: 6px 10px;
                font-size: 0.9em;
            }
            
            .custom-players-buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .custom-players-button {
                padding: 10px 20px;
                font-size: 1em;
                width: 100%;
            }
            
            /* Test Mode Panel */
            #testModePanel {
                padding: 20px;
                max-width: 90%;
            }
            
            #testModePanel h2 {
                font-size: 20px;
            }
            
            .test-section {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .test-button {
                padding: 8px 15px;
                font-size: 12px;
            }
            
            /* Roll History Panel */
            #rollHistoryPanel {
                padding: 20px;
                max-width: 90%;
            }
            
            .roll-history-title {
                font-size: 20px;
            }
            
            .roll-history-item {
                padding: 10px 12px;
            }
            
            /* Stats Panel */
            #statsPanel {
                padding: 20px;
                max-width: 90%;
            }
            
            .stats-title {
                font-size: 22px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .stat-value {
                font-size: 26px;
            }
            
            .player-stat-avatar {
                width: 35px;
                height: 35px;
            }
            
            /* Bracket View */
            .bracket-toggle-btn {
                padding: 8px 15px;
                font-size: 0.9em;
            }
            
            .bracket-avatar-small {
                width: 30px;
                height: 30px;
            }
            
            .bracket-player-name {
                font-size: 0.9em;
            }
            
            /* Replay Controls */
            #replayControls {
                min-width: 90%;
                padding: 15px 20px;
                bottom: env(safe-area-inset-bottom, 20px);
            }
            
            .replay-banner {
                font-size: 1em;
                padding: 6px 15px;
            }
            
            .replay-btn {
                padding: 8px 15px;
                font-size: 0.9em;
            }
            
            /* Splash Screen */
            .splash-title {
                font-size: 1.5em;
            }
            
            .splash-player-name {
                font-size: 1.5em;
            }
            
            .splash-player-id {
                font-size: 1em;
            }
            
            .splash-vs {
                font-size: 2.5em;
            }
            
            .splash-nft-container {
                width: 180px;
                height: 180px;
            }
            
            .splash-screen {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .splash-continue-btn {
                padding: 15px 40px;
                font-size: 1.2em;
            }
            
            .splash-replay-btn {
                padding: 15px 35px;
                font-size: 1.1em;
            }
            
            /* Winner Screen */
            .winner-title {
                font-size: 2.5em;
            }
            
            .winner-name {
                font-size: 2em;
            }
            
            .winner-nft-container {
                width: 180px;
                height: 180px;
            }
            
            .restart-button {
                padding: 12px 30px;
                font-size: 1.1em;
            }
            
            /* Keyboard Help */
            .keyboard-help-content {
                padding: 25px;
            }
            
            .keyboard-help-title {
                font-size: 1.8em;
            }
            
            .keyboard-shortcut-item {
                padding: 10px 12px;
            }
            
            .keyboard-key {
                padding: 6px 12px;
                font-size: 1em;
                min-width: 40px;
                margin-right: 12px;
            }
            
            .keyboard-description {
                font-size: 0.9em;
            }
            
            /* Reduce glow effects for performance */
            .match.active {
                box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
            }
            
            .boost-setup-screen, .bracket-section, .dice-section {
                box-shadow: 0 0 10px rgba(0, 212, 255, 0.1);
            }
        }

        /* Small Phones - 480px and below */
        @media (max-width: 480px) {
            body {
                padding: env(safe-area-inset-top, 15px) env(safe-area-inset-right, 15px) env(safe-area-inset-bottom, 15px) env(safe-area-inset-left, 15px);
            }
            
            h1 {
                font-size: 1.2em;
            }
            
            .subtitle {
                font-size: 0.9em;
            }
            
            /* Boost Setup */
            .setup-title {
                font-size: 1.4em;
            }
            
            .player-boost-list {
                padding: 10px;
            }
            
            .player-boost-avatar {
                width: 35px;
                height: 35px;
            }
            
            .player-boost-name {
                font-size: 0.85em;
            }
            
            .boost-label {
                font-size: 0.75em;
            }
            
            .boost-select {
                padding: 5px 8px;
                font-size: 0.8em;
            }
            
            .setup-button {
                padding: 10px 20px;
                font-size: 1em;
            }
            
            /* Game Area */
            .bracket-section, .dice-section {
                padding: 10px;
            }
            
            .round-title {
                font-size: 1.2em;
            }
            
            .match {
                padding: 10px;
                margin-bottom: 10px;
            }
            
            /* Player cards - extra small */
            .player {
                padding: 8px;
                margin: 5px 0;
            }
            
            .avatar {
                width: 35px;
                height: 35px;
                margin-right: 8px;
            }
            
            .player-name {
                font-size: 0.9em;
            }
            
            .boost-badge {
                padding: 2px 5px;
                font-size: 0.6em;
            }
            
            .dot {
                width: 12px;
                height: 12px;
            }
            
            /* Dice - smaller */
            .dice-container {
                gap: 15px;
                margin: 10px 0;
            }
            
            .die {
                width: 50px;
                height: 50px;
                font-size: 1.5em;
            }
            
            .dice-labels {
                gap: 15px;
                font-size: 0.9em;
            }
            
            .dice-label {
                width: 50px;
            }
            
            .match-info {
                font-size: 0.85em;
            }
            
            /* Buttons - smaller */
            .roll-button, .continue-button {
                padding: 10px 25px;
                font-size: 1em;
            }
            
            .reset-button {
                padding: 6px 10px;
                font-size: 0.75em;
            }
            
            .result-message {
                font-size: 1em;
            }
            
            /* Top buttons - even smaller */
            #soundToggle, #testModeToggle, #rollHistoryToggle, #statsToggle {
                padding: 5px 8px;
                font-size: 9px;
            }
            
            #rollHistoryToggle {
                top: env(safe-area-inset-top, 45px);
            }
            
            #statsToggle {
                top: env(safe-area-inset-top, 80px);
            }
            
            /* Notifications - smaller */
            #boostNotificationContainer {
                top: env(safe-area-inset-top, 115px);
                max-width: 200px;
            }
            
            .boost-notification-banner {
                padding: 8px 10px;
                font-size: 0.8em;
            }
            
            /* Modals - more compact */
            .custom-players-content {
                padding: 15px;
            }
            
            .custom-players-title {
                font-size: 1.3em;
            }
            
            .custom-player-icon {
                width: 30px;
                height: 30px;
            }
            
            .custom-player-input input {
                padding: 5px 8px;
                font-size: 0.85em;
            }
            
            .custom-players-button {
                padding: 8px 15px;
                font-size: 0.9em;
            }
            
            /* Panels - compact */
            #testModePanel, #rollHistoryPanel, #statsPanel {
                padding: 15px;
            }
            
            .test-button {
                padding: 6px 12px;
                font-size: 11px;
            }
            
            .stats-title {
                font-size: 18px;
            }
            
            .stat-value {
                font-size: 22px;
            }
            
            .player-stat-avatar {
                width: 30px;
                height: 30px;
            }
            
            /* Bracket */
            .bracket-toggle-btn {
                padding: 6px 12px;
                font-size: 0.85em;
            }
            
            .bracket-avatar-small {
                width: 25px;
                height: 25px;
            }
            
            .bracket-player-name {
                font-size: 0.85em;
            }
            
            /* Replay Controls */
            #replayControls {
                min-width: 95%;
                padding: 12px 15px;
            }
            
            .replay-banner {
                font-size: 0.9em;
            }
            
            .replay-btn {
                padding: 6px 12px;
                font-size: 0.85em;
            }
            
            /* Splash Screen */
            .splash-title {
                font-size: 1.2em;
            }
            
            .splash-player-name {
                font-size: 1.2em;
            }
            
            .splash-player-id {
                font-size: 0.85em;
            }
            
            .splash-vs {
                font-size: 2em;
            }
            
            .splash-nft-container {
                width: 140px;
                height: 140px;
            }
            
            .splash-continue-btn {
                padding: 12px 30px;
                font-size: 1.1em;
            }
            
            .splash-replay-btn {
                padding: 12px 25px;
                font-size: 1em;
            }
            
            .splash-gang-name {
                font-size: 1em;
            }
            
            /* Winner Screen */
            .winner-title {
                font-size: 2em;
            }
            
            .winner-name {
                font-size: 1.5em;
            }
            
            .winner-nft-container {
                width: 150px;
                height: 150px;
            }
            
            .restart-button {
                padding: 10px 25px;
                font-size: 1em;
            }
            
            /* Keyboard Help */
            .keyboard-help-content {
                padding: 20px;
            }
            
            .keyboard-help-title {
                font-size: 1.5em;
            }
            
            .keyboard-help-section-title {
                font-size: 1.1em;
            }
            
            .keyboard-shortcut-item {
                padding: 8px 10px;
            }
            
            .keyboard-key {
                padding: 5px 10px;
                font-size: 0.9em;
                min-width: 35px;
                margin-right: 10px;
            }
            
            .keyboard-description {
                font-size: 0.85em;
            }
            
            .keyboard-help-close {
                padding: 10px 20px;
                font-size: 1em;
            }
        }

        /* Short screens - height optimization */
        @media (max-height: 700px) {
            .dice-section {
                padding: 10px;
            }
            
            .dice-container {
                margin: 10px 0;
            }
            
            .die {
                width: 50px;
                height: 50px;
                font-size: 1.5em;
            }
            
            .roll-button, .continue-button {
                padding: 8px 20px;
                font-size: 1em;
                margin-top: 8px;
            }
            
            .reset-buttons {
                margin-top: 8px;
            }
            
            .match {
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .player {
                padding: 8px;
                margin: 5px 0;
            }
        }

        /* ==== */
        /* MATCH REPLAY SYSTEM */
        /* ==== */

        #replayControls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid #ff6b00;
            border-radius: 15px;
            padding: 20px 30px;
            z-index: 10000;
            box-shadow: 0 0 30px rgba(255, 107, 0, 0.6);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            min-width: 500px;
        }

        #replayControls.active {
            display: flex;
        }

        .replay-banner {
            background: linear-gradient(135deg, #ff6b00 0%, #ff9500 100%);
            color: #000;
            font-weight: bold;
            font-size: 1.2em;
            padding: 8px 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.5);
            animation: replayPulse 2s ease-in-out infinite;
        }

        @keyframes replayPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 107, 0, 0.5);
            }
            50% {
                box-shadow: 0 0 35px rgba(255, 107, 0, 0.8);
            }
        }

        .replay-info {
            color: #fff;
            font-size: 1em;
            text-align: center;
        }

        .replay-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .replay-btn {
            background: linear-gradient(135deg, #ff6b00 0%, #ff9500 100%);
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 3px 10px rgba(255, 107, 0, 0.3);
        }

        .replay-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 0, 0.5);
        }

        .replay-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .replay-btn.exit {
            background: linear-gradient(135deg, #6c5ce7 0%, #5f4dd1 100%);
        }

        .replay-slider-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .replay-slider {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .replay-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff6b00;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 0, 0.6);
        }

        .replay-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff6b00;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 0, 0.6);
            border: none;
        }

        .replay-position {
            color: #ff6b00;
            font-weight: bold;
            font-size: 1.1em;
            min-width: 80px;
            text-align: center;
        }

        /* Sudden Death Replay Indicator */
        .replay-sudden-death-badge {
            background: linear-gradient(135deg, #ff0000 0%, #ff4444 100%);
            color: #fff;
            font-weight: bold;
            font-size: 0.9em;
            padding: 5px 12px;
            border-radius: 6px;
            display: inline-block;
            margin-left: 10px;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
            animation: suddenDeathPulse 1.5s ease-in-out infinite;
        }

        @keyframes suddenDeathPulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
            }
            50% {
                box-shadow: 0 0 25px rgba(255, 0, 0, 0.9);
            }
        }

        /* Sudden Death Border for Replay Controls */
        #replayControls.sudden-death {
            border-color: #ff0000;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.7);
        }

        /* Dim game area during replay */
        body.replay-mode .game-area {
            opacity: 0.7;
            pointer-events: none;
        }

        body.replay-mode .roll-button {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ==== */
        /* WINNER EFFECTS */
        /* ==== */

        /* Confetti particles */
        .confetti-particle {
            position: fixed;
            width: 10px;
            height: 10px;
            pointer-events: none;
            z-index: 9999;
            animation: confettiFall 2s ease-out forwards;
        }

        @keyframes confettiFall {
            0% {
                transform: translate(0, 0) rotate(0deg) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--vx), var(--vy)) rotate(var(--rotation)) scale(0.3);
                opacity: 0;
            }
        }

        /* Winner card celebration */
        .player.winner-celebration {
            animation: winnerPulse 0.8s ease-in-out;
            position: relative;
            z-index: 100;
        }

        @keyframes winnerPulse {
            0%, 100% {
                transform: scale(1);
            }
            25% {
                transform: scale(1.1);
            }
            50% {
                transform: scale(1.05);
            }
            75% {
                transform: scale(1.12);
            }
        }

        /* Screen flash effect */
        .screen-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9998;
            animation: flashFade 0.6s ease-out forwards;
        }

        @keyframes flashFade {
            0% {
                opacity: 0.6;
            }
            100% {
                opacity: 0;
            }
        }

        /* Trophy icon */
        .winner-trophy {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 3em;
            animation: trophyBounce 1s ease-out forwards;
            z-index: 101;
        }

        @keyframes trophyBounce {
            0% {
                transform: translateX(-50%) translateY(50px) scale(0);
                opacity: 0;
            }
            50% {
                transform: translateX(-50%) translateY(-10px) scale(1.2);
                opacity: 1;
            }
            70% {
                transform: translateX(-50%) translateY(5px) scale(0.9);
            }
            100% {
                transform: translateX(-50%) translateY(0) scale(1);
                opacity: 0;
            }
        }

        /* Particle burst effect */
        .particle-burst {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
        }

        @keyframes particleBurst {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        /* ==== */
        /* SPLASH SCREEN SYSTEM */
        /* ==== */

        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            animation: splashFadeIn 0.5s ease;
        }

        .splash-screen.show {
            display: flex;
        }

        @keyframes splashFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .splash-content {
            text-align: center;
            max-width: 1200px;
            width: 90%;
        }

        .splash-title {
            font-size: 3em;
            color: #00d4ff;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
            margin-bottom: 40px;
            animation: splashTitlePulse 2s ease-in-out infinite;
        }

        @keyframes splashTitlePulse {
            0%, 100% {
                text-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
            }
            50% {
                text-shadow: 0 0 50px rgba(0, 212, 255, 1),
                            0 0 80px rgba(0, 212, 255, 0.6);
            }
        }

        .splash-players {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 80px;
            margin-bottom: 40px;
        }

        .splash-player {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
        }

        .splash-nft-container {
            position: relative;
            width: 400px;
            height: 400px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 5px solid;
            animation: splashNFTPulse 2s ease-in-out infinite;
        }

        @keyframes splashNFTPulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        .splash-nft-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
        }

        .splash-loser-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .splash-loser-x {
            font-size: 15em;
            color: #ff0000;
            font-weight: bold;
            text-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
            animation: splashXAppear 0.5s ease;
        }

        @keyframes splashXAppear {
            from {
                transform: scale(0) rotate(-180deg);
                opacity: 0;
            }
            to {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .splash-player-name {
            font-size: 2.5em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        .splash-player-id {
            font-size: 1.5em;
            color: #aaa;
        }

        .splash-vs {
            font-size: 5em;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            margin: 0 40px;
            transform: translateY(-40px);
        }

        .splash-gang-name {
            font-size: 1.2em;
            font-weight: bold;
            text-transform: uppercase;
            margin-top: 5px;
            letter-spacing: 1px;
        }

        .splash-interference-info {
            color: #ff6b00;
            font-weight: bold;
            margin-top: 10px;
            font-size: 1.1em;
            text-shadow: 0 0 10px rgba(255, 107, 0, 0.3);
        }

        /* Winner Screen NFT Style */
        .winner-nft-container {
            width: 250px;
            height: 250px;
            margin: 0 auto 20px;
            border: 8px solid #00d4ff;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.5);
        }

        .winner-nft-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .splash-continue-btn {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #fff;
            border: none;
            padding: 20px 60px;
            font-size: 1.5em;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.5);
            font-weight: bold;
        }

        .splash-continue-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0, 212, 255, 0.7);
        }

        .splash-actions{
            display:flex;
            gap:20px;
            justify-content:center;
            flex-wrap:wrap;
        }

        .splash-replay-btn{
            background: linear-gradient(135deg, #ff6b00 0%, #ff9500 100%);
            color:#fff;
            border:none;
            padding:20px 50px;
            font-size:1.3em;
            border-radius:15px;
            cursor:pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(255, 107, 0, 0.45);
            font-weight:bold;
        }

        .splash-replay-btn:hover{
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(255, 107, 0, 0.7);
        }

        .splash-match-info {
            font-size: 1.3em;
            color: #aaa;
            margin-bottom: 30px;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .splash-players {
                flex-direction: column;
                gap: 40px;
            }
            
            .splash-vs {
                transform: rotate(90deg);
            }
            
            .splash-nft-container {
                width: 300px;
                height: 300px;
            }
        }

        /* ==== */
        /* ADDITIONAL MOBILE FIXES - V2Z */
        /* ==== */

        @media (max-width: 768px) {
            /* CRITICAL FIX #1: Fixed Header Bar for Top Buttons */
            #mobileHeaderBar {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: rgba(26, 26, 46, 0.95);
                backdrop-filter: blur(10px);
                padding: env(safe-area-inset-top, 10px) 10px 10px 10px;
                z-index: 10000;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 2px solid rgba(0, 212, 255, 0.3);
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            }
            
            /* Reposition top buttons into header */
            #soundToggle {
                position: static;
                margin: 0;
            }
            
            #testModeToggle, #rollHistoryToggle, #statsToggle {
                position: static;
                margin: 0;
            }
            
            /* Add top padding to body to account for fixed header */
            body {
                padding-top: calc(env(safe-area-inset-top, 10px) + 50px) !important;
            }
            
            /* CRITICAL FIX #2: Shortcuts Button - Bottom Right Floating */
            .shortcuts-btn {
                position: fixed !important;
                bottom: calc(env(safe-area-inset-bottom, 20px) + 20px) !important;
                right: 20px !important;
                z-index: 9999 !important;
                background: rgba(0, 212, 255, 0.9) !important;
                backdrop-filter: blur(10px) !important;
                box-shadow: 0 4px 15px rgba(0, 212, 255, 0.5) !important;
                border: 2px solid #00d4ff !important;
                padding: 10px 15px !important;
                border-radius: 50px !important;
                font-size: 12px !important;
                font-weight: bold !important;
            }
            
            /* CRITICAL FIX #3: Splash Screen - Add Top Padding */
            .splash-content {
                padding-top: calc(env(safe-area-inset-top, 20px) + 40px);
                max-height: 100vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .splash-nft-container {
                width: 200px !important;
                height: 200px !important;
                margin-top: 20px;
            }
            
            .splash-title {
                font-size: 1.8em !important;
                margin-bottom: 20px !important;
                margin-top: 0 !important;
            }
            
            .splash-players {
                flex-direction: column;
                gap: 30px !important;
                margin-bottom: 30px !important;
            }
            
            .splash-vs {
                transform: rotate(90deg);
                font-size: 2em !important;
                margin: 10px 0 !important;
            }
            
            .splash-player-name {
                font-size: 1.3em !important;
            }
            
            .splash-player-id {
                font-size: 0.9em !important;
            }
            
            .splash-gang-name {
                font-size: 0.95em !important;
            }
            
            .splash-match-info {
                font-size: 1em !important;
                margin-bottom: 20px !important;
            }
            
            .splash-continue-btn {
                padding: 12px 35px !important;
                font-size: 1.1em !important;
                margin-bottom: calc(env(safe-area-inset-bottom, 20px) + 10px);
            }
            
            .splash-replay-btn {
                padding: 12px 30px !important;
                font-size: 1em !important;
            }
            
            /* CRITICAL FIX #4: Replay Controls - Bottom Safe Area */
            #replayControls {
                bottom: calc(env(safe-area-inset-bottom, 20px) + 10px) !important;
                min-width: 95% !important;
                padding: 12px 15px !important;
                gap: 10px !important;
            }
            
            .replay-banner {
                font-size: 0.95em !important;
                padding: 6px 12px !important;
            }
            
            .replay-info {
                font-size: 0.9em !important;
            }
            
            .replay-buttons {
                flex-wrap: wrap;
                gap: 8px !important;
            }
            
            .replay-btn {
                padding: 8px 12px !important;
                font-size: 0.85em !important;
            }
            
            .replay-slider-container {
                flex-direction: column;
                gap: 8px !important;
            }
            
            .replay-position {
                font-size: 0.95em !important;
            }
            
            /* Reduce glow effects on mobile for better performance */
            h1 {
                animation: none !important;
                text-shadow: 0 0 15px rgba(0, 212, 255, 0.5) !important;
            }
            
            .match.active {
                animation: none !important;
                box-shadow: 0 0 10px rgba(0, 212, 255, 0.3) !important;
            }
            
            .boost-notification-banner {
                animation: bannerSlideIn 0.5s ease !important;
            }
            
            /* Reduce border thickness */
            .match, .player, .boost-badge {
                border-width: 1px !important;
            }
            
            .bracket-section, .dice-section, .boost-setup-screen {
                border-width: 2px !important;
            }
        }

        @media (max-width: 480px) {
            /* Extra small phones - even more compact */
            .splash-nft-container {
                width: 160px !important;
                height: 160px !important;
            }
            
            .splash-title {
                font-size: 1.4em !important;
            }
            
            .splash-player-name {
                font-size: 1.1em !important;
            }
            
            .splash-vs {
                font-size: 1.5em !important;
            }
            
            #replayControls {
                min-width: 98% !important;
                padding: 10px 12px !important;
            }
            
            .replay-btn {
                padding: 6px 10px !important;
                font-size: 0.8em !important;
            }
        }

        /* Landscape orientation fixes */
        @media (max-width: 768px) and (orientation: landscape) {
            .splash-players {
                flex-direction: row !important;
                gap: 40px !important;
            }
            
            .splash-vs {
                transform: rotate(0deg) !important;
                margin: 0 20px !important;
            }
            
            .splash-nft-container {
                width: 150px !important;
                height: 150px !important;
            }
        }

</style>
</head>
<body>
    <!-- Sound Toggle Button -->
    <button id="soundToggle" onclick="toggleSound()">🔊 SOUND ON</button>

    <!-- Keyboard Shortcuts Help Overlay -->
    <div id="keyboardHelpOverlay">
        <div class="keyboard-help-content">
            <div class="keyboard-help-title">⌨️ Keyboard Shortcuts</div>
            
            <div class="keyboard-help-section">
                <div class="keyboard-help-section-title">🎮 Game Controls</div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">SPACE</div>
                    <div class="keyboard-description">Roll the dice (when enabled)</div>
                </div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">U</div>
                    <div class="keyboard-description">Undo last roll</div>
                </div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">R</div>
                    <div class="keyboard-description">Enter match replay mode</div>
                </div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">M</div>
                    <div class="keyboard-description">Mute/unmute sounds</div>
                </div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">S</div>
                    <div class="keyboard-description">View statistics panel</div>
                </div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">P</div>
                    <div class="keyboard-description">Reset current match</div>
                </div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">O</div>
                    <div class="keyboard-description">Reset current round</div>
                </div>
            </div>
            
            <div class="keyboard-help-section">
                <div class="keyboard-help-section-title">👁️ View Controls</div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">B</div>
                    <div class="keyboard-description">Toggle bracket view (Current Match ↔ Full Bracket)</div>
                </div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">H</div>
                    <div class="keyboard-description">Toggle roll history panel</div>
                </div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">← →</div>
                    <div class="keyboard-description">Navigate replay (when in replay mode)</div>
                </div>
            </div>
            
            <div class="keyboard-help-section">
                <div class="keyboard-help-section-title">🧪 Developer Tools</div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">T</div>
                    <div class="keyboard-description">Toggle test mode panel</div>
                </div>
            </div>
            
            <div class="keyboard-help-section">
                <div class="keyboard-help-section-title">ℹ️ Help</div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">?</div>
                    <div class="keyboard-description">Show/hide this help overlay</div>
                </div>
                <div class="keyboard-shortcut-item">
                    <div class="keyboard-key">ESC</div>
                    <div class="keyboard-description">Close this help overlay</div>
                </div>
            </div>
            
            <button class="keyboard-help-close" onclick="toggleKeyboardHelp()">Close</button>
            
            <div class="keyboard-help-footer">
                Press <strong>?</strong> anytime to view shortcuts
            </div>
        </div>
    </div>

    <!-- Tooltip Element -->
    <div id="tooltip" class="tooltip">
        <div class="tooltip-title"></div>
        <div class="tooltip-description"></div>
    </div>

    <!-- Enhanced Notification Container -->
    <div id="boostNotificationContainer"></div>

    <div class="container">
        <header>
            <h1>META8 SHOWDOWN: BRAWL</h1>
            <p class="subtitle">Tournament Battle System</p>
        </header>

        <!-- Boost Setup Screen -->
        <div class="boost-setup-screen show" id="boostSetupScreen">
            <div class="setup-title">⚡ Boost Assignment ⚡</div>
            <div class="player-boost-list" id="playerBoostList">
                <!-- Player boost assignments will be generated here -->
            </div>
            <div class="setup-buttons">
                <button class="setup-button secondary" onclick="openCustomPlayersPopup()">👥 Custom Players</button>
                <button class="setup-button secondary" id="randomizeButton">🎲 Randomize Boosts</button>
                <button class="setup-button" id="startTournamentButton">▶ Start Tournament</button>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area" id="gameArea">
            <div class="bracket-section" id="bracketSection">
                <!-- View Toggle -->
                <div class="bracket-view-toggle">
                    <button class="bracket-toggle-btn active" id="currentMatchBtn" onclick="switchBracketView('current')">Current Match</button>
                    <button class="bracket-toggle-btn" id="fullBracketBtn" onclick="switchBracketView('full')">Full Bracket</button>
                </div>
                
                <!-- Current Match View -->
                <div id="currentMatchView">
                    <!-- Current match will be rendered here -->
                </div>
                
                <!-- Full Bracket View -->
                <div class="full-bracket-container" id="fullBracketView">
                    <!-- Full bracket will be rendered here -->
                </div>
            </div>

            <div class="dice-section">
                <div class="match-info" id="matchInfo">Ready to start!</div>
                <div class="dice-labels">
                    <div class="dice-label" id="player1Label">Player 1</div>
                    <div class="dice-label" id="player2Label">Player 2</div>
                </div>
                <div class="dice-container">
                    <div class="die" id="die1">?</div>
                    <div class="die" id="die2">?</div>
                </div>
                <button class="roll-button" id="rollButton">ROLL DICE</button>
                <button class="continue-button" id="continueButton">CONTINUE ▶</button>
                <div class="reset-buttons">
                    <button id="undoRollButton" class="reset-button">↶ Undo Last Roll</button>
                    <button id="resetMatchButton" class="reset-button">⟲ Reset Match</button>
                    <button id="resetRoundButton" class="reset-button">⟳ Reset Round</button>
                </div>
                <div class="result-message" id="resultMessage"></div>
                <div id="boostNotification"></div>
            </div>
        </div>
    </div>

    <!-- Custom Players Popup -->
    <div id="customPlayersPopup">
        <div class="custom-players-content">
            <div class="custom-players-title">👥 Custom Players</div>
            <div id="customPlayersInputs">
                <!-- Player inputs will be generated here -->
            </div>
            <div class="error-message" id="customPlayersError"></div>
            <div class="custom-players-buttons">
                <button class="custom-players-button" onclick="applyCustomPlayers()">✓ Apply</button>
                <button class="custom-players-button cancel" onclick="closeCustomPlayersPopup()">✗ Cancel</button>
            </div>
        </div>
    </div>

    <!-- Match Splash Screen -->
    <div class="splash-screen" id="matchSplashScreen">
        <div class="splash-content">
            <div class="splash-title" id="splashTitle">MATCH START</div>
            <div class="splash-match-info" id="splashMatchInfo">Round 1 - Match 1</div>
            <div class="splash-players" id="splashPlayers">
                <!-- Players will be rendered here -->
            </div>
            <div class="splash-actions">
                <button class="splash-replay-btn" id="splashReplayBtn" onclick="replayFromEndSplash()" style="display:none;">
                    🎬 REPLAY MATCH
                </button>
                <button class="splash-continue-btn" id="splashContinueBtn" onclick="hideSplashScreen()">
                    START MATCH ▶
                </button>
            </div>
        </div>
    </div>

    <div class="winner-screen" id="winnerScreen">
        <div class="winner-content">
            <div class="winner-title">🏆 CHAMPION 🏆</div>
            <div class="winner-nft-container" id="winnerNFTContainer">
                <img id="winnerNFTImg" src="" alt="Champion">
            </div>
            <div class="winner-name" id="winnerName"></div>
            <div id="winnerGang" style="font-size: 1.5em; font-weight: bold; margin-bottom: 10px;"></div>
            <div id="winnerRiderId" style="color: #aaa; margin-bottom: 30px;"></div>
            <button class="restart-button" id="restartButton">NEW TOURNAMENT</button>
            <!--  <button class="restart-button" onclick="resetTournament()">NEW TOURNAMENT</button> -->
        </div>
    </div>

    <script>

        // Convert hex color to RGB for rgba usage
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? 
                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
                '0, 212, 255';
        }

        // Build NFT image URL from riderId (1-1000)
        function getPlayerNFTUrl(riderId) {
            const baseUrl = "https://harlequin-advanced-silkworm-824.mypinata.cloud/ipfs/QmRGYEj9vQK1QUaGdkJxXj2nKquAxgLFJhhah4GJWqyNgt/";
            const id = parseInt(riderId, 10);

            if (!id || id < 1 || id > 1000) {
                // Fallback: use ID 1 if invalid, so we always show *something*
                return baseUrl + "1.png";
            }

            return baseUrl + id + ".png";
        }

        // ========================================
        // WEB AUDIO API SOUND SYSTEM - V2
        // ========================================
        
        let audioContext;
        let soundEnabled = true;

        // Initialize Audio Context (lazy initialization to avoid autoplay issues)
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            return audioContext;
        }

        // Sound toggle function
        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('soundToggle');
            if (soundEnabled) {
                btn.textContent = '🔊 SOUND ON';
                btn.classList.remove('muted');
            } else {
                btn.textContent = '🔇 SOUND OFF';
                btn.classList.add('muted');
            }
        }

        // Generic sound generator
        function playSound(type, frequency = 440, duration = 0.2) {
            if (!soundEnabled) return;
            
            const ctx = initAudio();
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type; // 'sine', 'square', 'sawtooth', 'triangle'
            
            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
            
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + duration);
        }

        // Boost-specific sounds
        function playBoostSound(boostName) {
            console.log(`playBoostSound called with: ${boostName}, soundEnabled: ${soundEnabled}`);
            if (!soundEnabled) return;
            
            const ctx = initAudio();
            console.log(`Audio context state: ${ctx.state}`);
            
            switch(boostName) {
                case 'nosdemon':
                    // Lightning strike - fast rising pitch
                    [300, 400, 500, 600].forEach((freq, i) => {
                        setTimeout(() => playSound('sawtooth', freq, 0.1), i * 30);
                    });
                    break;
                    
                case 'revive':
                    // Resurrection - ascending tones
                    [200, 300, 400, 500, 600].forEach((freq, i) => {
                        setTimeout(() => playSound('sine', freq, 0.15), i * 50);
                    });
                    break;
                    
                case 'thief':
                    // Steal - quick wobble
                    playSound('square', 300, 0.1);
                    setTimeout(() => playSound('square', 350, 0.1), 100);
                    setTimeout(() => playSound('square', 400, 0.15), 200);
                    break;
                    
                case 'guardian':
                    // Shield - deep resonant tone
                    playSound('sine', 150, 0.4);
                    setTimeout(() => playSound('sine', 200, 0.3), 100);
                    break;
                    
                case 'brawler':
                    // Combat - aggressive beeps
                    playSound('square', 400, 0.08);
                    setTimeout(() => playSound('square', 350, 0.08), 80);
                    setTimeout(() => playSound('square', 450, 0.12), 160);
                    break;
                    
                case 'scavenger':
                    // Collect - coin-like sound
                    playSound('triangle', 800, 0.1);
                    setTimeout(() => playSound('triangle', 1000, 0.15), 100);
                    break;
                    
                case 'doubleplay':
                    // Echo - two identical tones
                    playSound('sine', 500, 0.2);
                    setTimeout(() => playSound('sine', 500, 0.2), 150);
                    break;
                    
                default:
                    playSound('sine', 440, 0.2);
            }
        }

        // Roll dice sound
        function playDiceRollSound() {
            if (!soundEnabled) return;
            
            // Dice rolling - random frequencies
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    playSound('square', 200 + Math.random() * 200, 0.05);
                }, i * 50);
            }
        }

        // Win sound
        function playWinSound() {
            if (!soundEnabled) return;
            
            // Victory fanfare
            [400, 500, 600, 800].forEach((freq, i) => {
                setTimeout(() => playSound('sine', freq, 0.3), i * 100);
            });
        }

        // Tie sound
        function playTieSound() {
            if (!soundEnabled) return;
            playSound('triangle', 300, 0.2);
            setTimeout(() => playSound('triangle', 300, 0.2), 200);
        }

        // Match complete sound
        function playMatchCompleteSound() {
            if (!soundEnabled) return;
            
            // Completion chime
            [600, 800, 1000].forEach((freq, i) => {
                setTimeout(() => playSound('sine', freq, 0.25), i * 120);
            });
        }

        // Champion sound
        function playChampionSound() {
            if (!soundEnabled) return;
            
            // Epic victory
            [400, 500, 600, 800, 1000, 1200].forEach((freq, i) => {
                setTimeout(() => playSound('sine', freq, 0.35), i * 100);
            });
        }

        // Gang Takeover sound - Epic celebration
        function playGangTakeoverSound() {
            if (!soundEnabled) return;
            
            const ctx = initAudio();
            
            // Epic ascending fanfare
            const fanfareNotes = [400, 500, 600, 700, 800, 1000, 1200];
            
            fanfareNotes.forEach((freq, index) => {
                setTimeout(() => {
                    // Main note
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.4);
                    
                    // Harmony note (adds richness)
                    setTimeout(() => {
                        const harmOsc = ctx.createOscillator();
                        const harmGain = ctx.createGain();
                        
                        harmOsc.connect(harmGain);
                        harmGain.connect(ctx.destination);
                        
                        harmOsc.type = 'triangle';
                        harmOsc.frequency.value = freq * 1.5; // Fifth above
                        
                        harmGain.gain.setValueAtTime(0.15, ctx.currentTime);
                        harmGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                        
                        harmOsc.start(ctx.currentTime);
                        harmOsc.stop(ctx.currentTime + 0.3);
                    }, 50);
                }, index * 120);
            });
            
            // Add deep bass rumble for impact
            setTimeout(() => {
                playSound('sine', 80, 1.0);
            }, 300);
        }

        // Cosmic Storm sound - Ominous electric crackling
        function playCosmicStormSound() {
            if (!soundEnabled) return;
            
            const ctx = initAudio();
            
            // Create multiple oscillators for complex storm effect
            const frequencies = [100, 150, 200, 250, 300];
            
            frequencies.forEach((baseFreq, index) => {
                setTimeout(() => {
                    // Crackling effect with random frequency modulation
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);
                    
                    // Random frequency wobble for crackling
                    for (let i = 0; i < 10; i++) {
                        const time = ctx.currentTime + (i * 0.05);
                        const freq = baseFreq + (Math.random() * 100 - 50);
                        osc.frequency.setValueAtTime(freq, time);
                    }
                    
                    gain.gain.setValueAtTime(0.15, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.5);
                }, index * 100);
            });
            
            // Add deep rumble
            setTimeout(() => {
                playSound('sine', 60, 0.8);
            }, 200);
        }

        // Decryptor Interference sound - Digital glitch effect
        function playDecryptorSound() {
            if (!soundEnabled) return;
            
            const ctx = initAudio();
            
            // Glitchy digital sound with rapid frequency changes
            const glitchFrequencies = [800, 600, 1000, 400, 1200, 500, 900];
            
            glitchFrequencies.forEach((freq, index) => {
                setTimeout(() => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    
                    gain.gain.setValueAtTime(0.2, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.08);
                }, index * 60);
            });
            
            // Add low digital buzz
            setTimeout(() => {
                playSound('square', 200, 0.3);
            }, 100);
        }

        // ========================================
        // BOOST ANIMATION SYSTEM
        // ========================================
        
        function triggerBoostAnimation(playerElement, boostName) {
            if (!playerElement) {
                console.log(`No player element found for boost animation: ${boostName}`);
                return;
            }
            
            console.log(`Triggering animation for ${boostName} on player element`);
            
            // Add animation class to player element
            const animationClass = `boost-activate-${boostName}`;
            playerElement.classList.add(animationClass);
            
            // Also animate the boost badge if it exists
            const boostBadges = playerElement.querySelectorAll('.boost-badge');
            boostBadges.forEach(badge => {
                const badgeBoostName = badge.getAttribute('data-boost-name');
                if (badgeBoostName && badgeBoostName.toLowerCase().includes(boostName)) {
                    badge.classList.add(animationClass);
                    setTimeout(() => {
                        badge.classList.remove(animationClass);
                    }, 1000);
                }
            });
            
            // Play sound
            playBoostSound(boostName);
            
            // Remove animation class after animation completes
            setTimeout(() => {
                playerElement.classList.remove(animationClass);
            }, 1000);
        }

        // Find player element by player object
        function findPlayerElement(player) {
            // Find the player element in the DOM
            const players = document.querySelectorAll('.player');
            for (let el of players) {
                const nameEl = el.querySelector('.player-name');
                if (nameEl && nameEl.textContent.includes(player.name)) {
                    return el;
                }
            }
            return null;
        }

        // ========================================
        // ENHANCED NOTIFICATION SYSTEM
        // ========================================
        
        function showEnhancedNotification(message, duration = 3000) {
            const container = document.getElementById('boostNotificationContainer');
            
            // Create notification banner
            const banner = document.createElement('div');
            banner.className = 'boost-notification-banner';
            banner.innerHTML = message;
            
            container.appendChild(banner);
            
            // Auto-dismiss
            setTimeout(() => {
                banner.classList.add('slide-out');
                setTimeout(() => {
                    container.removeChild(banner);
                }, 500);
            }, duration);
        }

        // ========================================
        // TOOLTIP SYSTEM
        // ========================================
        
        const BOOST_DESCRIPTIONS = {
            'brawler': {
                name: 'Brawler',
                description: 'If opponent wins the first roll, nullify it and force a reroll.'
            },
            'guardian': {
                name: 'Guardian',
                description: 'Win the first roll → automatically win the second roll.'
            },
            'nosdemon': {
                name: 'NosDemon',
                description: 'Start the match with an automatic 1-0 lead.'
            },
            'revive': {
                name: 'Revive',
                description: 'If you lose the match, replay the final deciding roll.'
            },
            'saboteur': {
                name: 'Saboteur',
                description: 'Choose any gang\'s prize (visual/roleplay only).'
            },
            'thief': {
                name: 'Thief',
                description: 'Steal your opponent\'s primary boost at match start.'
            },
            'scavenger': {
                name: 'Scavenger',
                description: 'When you win, steal your opponent\'s boost for the next match.'
            },
            'doubleplay': {
                name: 'Double Play',
                description: 'Use your primary boost twice instead of once.'
            }
        };

        let tooltipTimeout;
        
        function showTooltip(event, boostId) {
            const tooltip = document.getElementById('tooltip');
            const boostInfo = BOOST_DESCRIPTIONS[boostId];
            
            if (!boostInfo) return;
            
            clearTimeout(tooltipTimeout);
            
            // Set tooltip content
            tooltip.querySelector('.tooltip-title').textContent = boostInfo.name;
            tooltip.querySelector('.tooltip-description').textContent = boostInfo.description;
            
            // Position tooltip
            const rect = event.target.getBoundingClientRect();
            tooltip.style.left = rect.left + (rect.width / 2) + 'px';
            tooltip.style.top = (rect.top - 10) + 'px';
            tooltip.style.transform = 'translate(-50%, -100%)';
            
            // Show tooltip
            tooltip.classList.add('show');
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltipTimeout = setTimeout(() => {
                tooltip.classList.remove('show');
            }, 100);
        }

        // Add tooltip listeners to boost badges
        function attachTooltipListeners() {
            document.querySelectorAll('.boost-badge').forEach(badge => {
                badge.addEventListener('mouseenter', showCustomTooltip);
                badge.addEventListener('mouseleave', hideCustomTooltip);
            });
        }

        function showCustomTooltip(event) {
            const badge = event.currentTarget;
            const boostName = badge.getAttribute('data-boost-name');
            const boostDescription = badge.getAttribute('title');
            
            if (!boostName || !boostDescription) return;
            
            const tooltip = document.getElementById('tooltip');
            tooltip.querySelector('.tooltip-title').textContent = boostName;
            tooltip.querySelector('.tooltip-description').textContent = boostDescription;
            
            // Position tooltip above the badge
            const rect = badge.getBoundingClientRect();
            tooltip.style.left = rect.left + (rect.width / 2) + 'px';
            tooltip.style.top = (rect.top - 10) + 'px';
            tooltip.style.transform = 'translate(-50%, -100%)';
            
            // Show tooltip
            tooltip.classList.add('show');
        }

        function hideCustomTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('show');
        }


        // ====
        // METADATA: Rider ID to Gang Mapping
        // ====

        const METADATA = {
            1: { gang: 'Bit Bandits', leader: '0-Day' },
            2: { gang: 'Talisman Tribe', leader: 'Himitsu' },
            3: { gang: 'Rogue Riders', leader: 'Bella' },
            4: { gang: 'Nexus Nomads', leader: 'Kyoto' },
            5: { gang: 'Talisman Tribe' },
            6: { gang: 'Nexus Nomads' },
            7: { gang: 'Rogue Riders' },
            8: { gang: 'Talisman Tribe' },
            9: { gang: 'Rogue Riders' },
            10: { gang: 'Nexus Nomads' },
            11: { gang: 'Bit Bandits' },
            12: { gang: 'Nexus Nomads' },
            13: { gang: 'Rogue Riders' },
            14: { gang: 'Bit Bandits' },
            15: { gang: 'Bit Bandits' },
            16: { gang: 'Talisman Tribe' },
            17: { gang: 'Talisman Tribe' },
            18: { gang: 'Bit Bandits' },
            19: { gang: 'Rogue Riders' },
            20: { gang: 'Bit Bandits' },
            21: { gang: 'Talisman Tribe' },
            22: { gang: 'Rogue Riders' },
            23: { gang: 'Talisman Tribe' },
            24: { gang: 'Talisman Tribe' },
            25: { gang: 'Bit Bandits' },
            26: { gang: 'Bit Bandits' },
            27: { gang: 'Nexus Nomads' },
            28: { gang: 'Talisman Tribe' },
            29: { gang: 'Nexus Nomads' },
            30: { gang: 'Nexus Nomads' },
            31: { gang: 'Talisman Tribe' },
            32: { gang: 'Bit Bandits' },
            33: { gang: 'Rogue Riders' },
            34: { gang: 'Nexus Nomads' },
            35: { gang: 'Talisman Tribe' },
            36: { gang: 'Talisman Tribe' },
            37: { gang: 'Bit Bandits' },
            38: { gang: 'Nexus Nomads' },
            39: { gang: 'Talisman Tribe' },
            40: { gang: 'Nexus Nomads' },
            41: { gang: 'Bit Bandits' },
            42: { gang: 'Rogue Riders' },
            43: { gang: 'Bit Bandits' },
            44: { gang: 'Bit Bandits' },
            45: { gang: 'Rogue Riders' },
            46: { gang: 'Rogue Riders' },
            47: { gang: 'Bit Bandits' },
            48: { gang: 'Talisman Tribe' },
            49: { gang: 'Nexus Nomads' },
            50: { gang: 'Talisman Tribe' },
            51: { gang: 'Rogue Riders' },
            52: { gang: 'Nexus Nomads' },
            53: { gang: 'Talisman Tribe' },
            54: { gang: 'Bit Bandits' },
            55: { gang: 'Nexus Nomads' },
            56: { gang: 'Bit Bandits' },
            57: { gang: 'Bit Bandits' },
            58: { gang: 'Bit Bandits' },
            59: { gang: 'Nexus Nomads' },
            60: { gang: 'Nexus Nomads' },
            61: { gang: 'Bit Bandits' },
            62: { gang: 'Rogue Riders' },
            63: { gang: 'Nexus Nomads' },
            64: { gang: 'Nexus Nomads' },
            65: { gang: 'Talisman Tribe' },
            66: { gang: 'Talisman Tribe' },
            67: { gang: 'Bit Bandits' },
            68: { gang: 'Bit Bandits' },
            69: { gang: 'Nexus Nomads' },
            70: { gang: 'Bit Bandits' },
            71: { gang: 'Nexus Nomads' },
            72: { gang: 'Rogue Riders' },
            73: { gang: 'Nexus Nomads' },
            74: { gang: 'Talisman Tribe' },
            75: { gang: 'Talisman Tribe' },
            76: { gang: 'Nexus Nomads' },
            77: { gang: 'Talisman Tribe' },
            78: { gang: 'Bit Bandits' },
            79: { gang: 'Nexus Nomads' },
            80: { gang: 'Bit Bandits' },
            81: { gang: 'Bit Bandits' },
            82: { gang: 'Nexus Nomads' },
            83: { gang: 'Nexus Nomads' },
            84: { gang: 'Bit Bandits' },
            85: { gang: 'Bit Bandits' },
            86: { gang: 'Talisman Tribe' },
            87: { gang: 'Bit Bandits' },
            88: { gang: 'Bit Bandits' },
            89: { gang: 'Bit Bandits' },
            90: { gang: 'Bit Bandits' },
            91: { gang: 'Talisman Tribe' },
            92: { gang: 'Talisman Tribe' },
            93: { gang: 'Nexus Nomads' },
            94: { gang: 'Bit Bandits' },
            95: { gang: 'Rogue Riders' },
            96: { gang: 'Rogue Riders' },
            97: { gang: 'Talisman Tribe' },
            98: { gang: 'Talisman Tribe' },
            99: { gang: 'Rogue Riders' },
            100: { gang: 'Rogue Riders' },
            101: { gang: 'Talisman Tribe' },
            102: { gang: 'Talisman Tribe' },
            103: { gang: 'Nexus Nomads' },
            104: { gang: 'Rogue Riders' },
            105: { gang: 'Bit Bandits' },
            106: { gang: 'Rogue Riders' },
            107: { gang: 'Bit Bandits' },
            108: { gang: 'Bit Bandits' },
            109: { gang: 'Talisman Tribe' },
            110: { gang: 'Rogue Riders' },
            111: { gang: 'Nexus Nomads' },
            112: { gang: 'Talisman Tribe' },
            113: { gang: 'Nexus Nomads' },
            114: { gang: 'Rogue Riders' },
            115: { gang: 'Rogue Riders' },
            116: { gang: 'Talisman Tribe' },
            117: { gang: 'Talisman Tribe' },
            118: { gang: 'Bit Bandits' },
            119: { gang: 'Rogue Riders' },
            120: { gang: 'Rogue Riders' },
            121: { gang: 'Nexus Nomads' },
            122: { gang: 'Nexus Nomads' },
            123: { gang: 'Talisman Tribe' },
            124: { gang: 'Rogue Riders' },
            125: { gang: 'Talisman Tribe' },
            126: { gang: 'Rogue Riders' },
            127: { gang: 'Bit Bandits' },
            128: { gang: 'Bit Bandits' },
            129: { gang: 'Talisman Tribe' },
            130: { gang: 'Nexus Nomads' },
            131: { gang: 'Rogue Riders' },
            132: { gang: 'Nexus Nomads' },
            133: { gang: 'Nexus Nomads' },
            134: { gang: 'Nexus Nomads' },
            135: { gang: 'Bit Bandits' },
            136: { gang: 'Nexus Nomads' },
            137: { gang: 'Talisman Tribe' },
            138: { gang: 'Talisman Tribe' },
            139: { gang: 'Talisman Tribe' },
            140: { gang: 'Nexus Nomads' },
            141: { gang: 'Rogue Riders' },
            142: { gang: 'Rogue Riders' },
            143: { gang: 'Bit Bandits' },
            144: { gang: 'Nexus Nomads' },
            145: { gang: 'Nexus Nomads' },
            146: { gang: 'Bit Bandits' },
            147: { gang: 'Talisman Tribe' },
            148: { gang: 'Nexus Nomads' },
            149: { gang: 'Nexus Nomads' },
            150: { gang: 'Talisman Tribe' },
            151: { gang: 'Talisman Tribe' },
            152: { gang: 'Nexus Nomads' },
            153: { gang: 'Rogue Riders' },
            154: { gang: 'Talisman Tribe' },
            155: { gang: 'Nexus Nomads' },
            156: { gang: 'Nexus Nomads' },
            157: { gang: 'Talisman Tribe' },
            158: { gang: 'Bit Bandits' },
            159: { gang: 'Rogue Riders' },
            160: { gang: 'Talisman Tribe' },
            161: { gang: 'Nexus Nomads' },
            162: { gang: 'Bit Bandits' },
            163: { gang: 'Bit Bandits' },
            164: { gang: 'Rogue Riders' },
            165: { gang: 'Talisman Tribe' },
            166: { gang: 'Talisman Tribe' },
            167: { gang: 'Nexus Nomads' },
            168: { gang: 'Talisman Tribe' },
            169: { gang: 'Rogue Riders' },
            170: { gang: 'Talisman Tribe' },
            171: { gang: 'Nexus Nomads' },
            172: { gang: 'Nexus Nomads' },
            173: { gang: 'Nexus Nomads' },
            174: { gang: 'Nexus Nomads' },
            175: { gang: 'Bit Bandits' },
            176: { gang: 'Rogue Riders' },
            177: { gang: 'Talisman Tribe' },
            178: { gang: 'Talisman Tribe' },
            179: { gang: 'Rogue Riders' },
            180: { gang: 'Bit Bandits' },
            181: { gang: 'Bit Bandits' },
            182: { gang: 'Rogue Riders' },
            183: { gang: 'Talisman Tribe' },
            184: { gang: 'Talisman Tribe' },
            185: { gang: 'Rogue Riders' },
            186: { gang: 'Nexus Nomads' },
            187: { gang: 'Nexus Nomads' },
            188: { gang: 'Nexus Nomads' },
            189: { gang: 'Bit Bandits' },
            190: { gang: 'Bit Bandits' },
            191: { gang: 'Bit Bandits' },
            192: { gang: 'Bit Bandits' },
            193: { gang: 'Bit Bandits' },
            194: { gang: 'Talisman Tribe' },
            195: { gang: 'Bit Bandits' },
            196: { gang: 'Bit Bandits' },
            197: { gang: 'Nexus Nomads' },
            198: { gang: 'Nexus Nomads' },
            199: { gang: 'Rogue Riders' },
            200: { gang: 'Nexus Nomads' },
            201: { gang: 'Nexus Nomads' },
            202: { gang: 'Rogue Riders' },
            203: { gang: 'Bit Bandits' },
            204: { gang: 'Talisman Tribe' },
            205: { gang: 'Talisman Tribe' },
            206: { gang: 'Talisman Tribe' },
            207: { gang: 'Bit Bandits' },
            208: { gang: 'Rogue Riders' },
            209: { gang: 'Rogue Riders' },
            210: { gang: 'Nexus Nomads' },
            211: { gang: 'Bit Bandits' },
            212: { gang: 'Talisman Tribe' },
            213: { gang: 'Nexus Nomads' },
            214: { gang: 'Bit Bandits' },
            215: { gang: 'Talisman Tribe' },
            216: { gang: 'Bit Bandits' },
            217: { gang: 'Bit Bandits' },
            218: { gang: 'Bit Bandits' },
            219: { gang: 'Rogue Riders' },
            220: { gang: 'Rogue Riders' },
            221: { gang: 'Nexus Nomads' },
            222: { gang: 'Rogue Riders' },
            223: { gang: 'Nexus Nomads' },
            224: { gang: 'Bit Bandits' },
            225: { gang: 'Talisman Tribe' },
            226: { gang: 'Nexus Nomads' },
            227: { gang: 'Talisman Tribe' },
            228: { gang: 'Rogue Riders' },
            229: { gang: 'Nexus Nomads' },
            230: { gang: 'Nexus Nomads' },
            231: { gang: 'Rogue Riders' },
            232: { gang: 'Talisman Tribe' },
            233: { gang: 'Talisman Tribe' },
            234: { gang: 'Talisman Tribe' },
            235: { gang: 'Nexus Nomads' },
            236: { gang: 'Talisman Tribe' },
            237: { gang: 'Talisman Tribe' },
            238: { gang: 'Rogue Riders' },
            239: { gang: 'Nexus Nomads' },
            240: { gang: 'Talisman Tribe' },
            241: { gang: 'Nexus Nomads' },
            242: { gang: 'Bit Bandits' },
            243: { gang: 'Nexus Nomads' },
            244: { gang: 'Rogue Riders' },
            245: { gang: 'Rogue Riders' },
            246: { gang: 'Bit Bandits' },
            247: { gang: 'Rogue Riders' },
            248: { gang: 'Talisman Tribe' },
            249: { gang: 'Talisman Tribe' },
            250: { gang: 'Rogue Riders' },
            251: { gang: 'Rogue Riders' },
            252: { gang: 'Talisman Tribe' },
            253: { gang: 'Rogue Riders' },
            254: { gang: 'Bit Bandits' },
            255: { gang: 'Rogue Riders' },
            256: { gang: 'Nexus Nomads' },
            257: { gang: 'Nexus Nomads' },
            258: { gang: 'Talisman Tribe' },
            259: { gang: 'Rogue Riders' },
            260: { gang: 'Talisman Tribe' },
            261: { gang: 'Talisman Tribe' },
            262: { gang: 'Talisman Tribe' },
            263: { gang: 'Nexus Nomads' },
            264: { gang: 'Bit Bandits' },
            265: { gang: 'Talisman Tribe' },
            266: { gang: 'Nexus Nomads' },
            267: { gang: 'Talisman Tribe' },
            268: { gang: 'Talisman Tribe' },
            269: { gang: 'Rogue Riders' },
            270: { gang: 'Bit Bandits' },
            271: { gang: 'Bit Bandits' },
            272: { gang: 'Bit Bandits' },
            273: { gang: 'Rogue Riders' },
            274: { gang: 'Bit Bandits' },
            275: { gang: 'Talisman Tribe' },
            276: { gang: 'Nexus Nomads' },
            277: { gang: 'Talisman Tribe' },
            278: { gang: 'Rogue Riders' },
            279: { gang: 'Bit Bandits' },
            280: { gang: 'Talisman Tribe' },
            281: { gang: 'Talisman Tribe' },
            282: { gang: 'Rogue Riders' },
            283: { gang: 'Rogue Riders' },
            284: { gang: 'Talisman Tribe' },
            285: { gang: 'Nexus Nomads' },
            286: { gang: 'Nexus Nomads' },
            287: { gang: 'Nexus Nomads' },
            288: { gang: 'Talisman Tribe' },
            289: { gang: 'Rogue Riders' },
            290: { gang: 'Nexus Nomads' },
            291: { gang: 'Bit Bandits' },
            292: { gang: 'Rogue Riders' },
            293: { gang: 'Bit Bandits' },
            294: { gang: 'Nexus Nomads' },
            295: { gang: 'Bit Bandits' },
            296: { gang: 'Talisman Tribe' },
            297: { gang: 'Talisman Tribe' },
            298: { gang: 'Bit Bandits' },
            299: { gang: 'Rogue Riders' },
            300: { gang: 'Rogue Riders' },
            301: { gang: 'Talisman Tribe' },
            302: { gang: 'Talisman Tribe' },
            303: { gang: 'Rogue Riders' },
            304: { gang: 'Nexus Nomads' },
            305: { gang: 'Rogue Riders' },
            306: { gang: 'Nexus Nomads' },
            307: { gang: 'Rogue Riders' },
            308: { gang: 'Bit Bandits' },
            309: { gang: 'Bit Bandits' },
            310: { gang: 'Talisman Tribe' },
            311: { gang: 'Talisman Tribe' },
            312: { gang: 'Talisman Tribe' },
            313: { gang: 'Rogue Riders' },
            314: { gang: 'Rogue Riders' },
            315: { gang: 'Rogue Riders' },
            316: { gang: 'Rogue Riders' },
            317: { gang: 'Bit Bandits' },
            318: { gang: 'Nexus Nomads' },
            319: { gang: 'Talisman Tribe' },
            320: { gang: 'Nexus Nomads' },
            321: { gang: 'Nexus Nomads' },
            322: { gang: 'Bit Bandits' },
            323: { gang: 'Bit Bandits' },
            324: { gang: 'Nexus Nomads' },
            325: { gang: 'Bit Bandits' },
            326: { gang: 'Nexus Nomads' },
            327: { gang: 'Rogue Riders' },
            328: { gang: 'Bit Bandits' },
            329: { gang: 'Nexus Nomads' },
            330: { gang: 'Bit Bandits' },
            331: { gang: 'Bit Bandits' },
            332: { gang: 'Nexus Nomads' },
            333: { gang: 'Rogue Riders' },
            334: { gang: 'Talisman Tribe' },
            335: { gang: 'Nexus Nomads' },
            336: { gang: 'Nexus Nomads' },
            337: { gang: 'Nexus Nomads' },
            338: { gang: 'Bit Bandits' },
            339: { gang: 'Talisman Tribe' },
            340: { gang: 'Rogue Riders' },
            341: { gang: 'Rogue Riders' },
            342: { gang: 'Nexus Nomads' },
            343: { gang: 'Rogue Riders' },
            344: { gang: 'Nexus Nomads' },
            345: { gang: 'Bit Bandits' },
            346: { gang: 'Nexus Nomads' },
            347: { gang: 'Rogue Riders' },
            348: { gang: 'Talisman Tribe' },
            349: { gang: 'Talisman Tribe' },
            350: { gang: 'Rogue Riders' },
            351: { gang: 'Bit Bandits' },
            352: { gang: 'Nexus Nomads' },
            353: { gang: 'Talisman Tribe' },
            354: { gang: 'Nexus Nomads' },
            355: { gang: 'Bit Bandits' },
            356: { gang: 'Rogue Riders' },
            357: { gang: 'Rogue Riders' },
            358: { gang: 'Nexus Nomads' },
            359: { gang: 'Nexus Nomads' },
            360: { gang: 'Rogue Riders' },
            361: { gang: 'Talisman Tribe' },
            362: { gang: 'Talisman Tribe' },
            363: { gang: 'Bit Bandits' },
            364: { gang: 'Nexus Nomads' },
            365: { gang: 'Bit Bandits' },
            366: { gang: 'Talisman Tribe' },
            367: { gang: 'Bit Bandits' },
            368: { gang: 'Nexus Nomads' },
            369: { gang: 'Nexus Nomads' },
            370: { gang: 'Rogue Riders' },
            371: { gang: 'Nexus Nomads' },
            372: { gang: 'Talisman Tribe' },
            373: { gang: 'Talisman Tribe' },
            374: { gang: 'Nexus Nomads' },
            375: { gang: 'Bit Bandits' },
            376: { gang: 'Bit Bandits' },
            377: { gang: 'Rogue Riders' },
            378: { gang: 'Rogue Riders' },
            379: { gang: 'Bit Bandits' },
            380: { gang: 'Bit Bandits' },
            381: { gang: 'Rogue Riders' },
            382: { gang: 'Rogue Riders' },
            383: { gang: 'Nexus Nomads' },
            384: { gang: 'Bit Bandits' },
            385: { gang: 'Talisman Tribe' },
            386: { gang: 'Nexus Nomads' },
            387: { gang: 'Bit Bandits' },
            388: { gang: 'Rogue Riders' },
            389: { gang: 'Rogue Riders' },
            390: { gang: 'Rogue Riders' },
            391: { gang: 'Nexus Nomads' },
            392: { gang: 'Nexus Nomads' },
            393: { gang: 'Talisman Tribe' },
            394: { gang: 'Nexus Nomads' },
            395: { gang: 'Nexus Nomads' },
            396: { gang: 'Rogue Riders' },
            397: { gang: 'Bit Bandits' },
            398: { gang: 'Rogue Riders' },
            399: { gang: 'Talisman Tribe' },
            400: { gang: 'Nexus Nomads' },
            401: { gang: 'Nexus Nomads' },
            402: { gang: 'Rogue Riders' },
            403: { gang: 'Bit Bandits' },
            404: { gang: 'Nexus Nomads' },
            405: { gang: 'Nexus Nomads' },
            406: { gang: 'Rogue Riders' },
            407: { gang: 'Talisman Tribe' },
            408: { gang: 'Talisman Tribe' },
            409: { gang: 'Rogue Riders' },
            410: { gang: 'Bit Bandits' },
            411: { gang: 'Rogue Riders' },
            412: { gang: 'Talisman Tribe' },
            413: { gang: 'Rogue Riders' },
            414: { gang: 'Bit Bandits' },
            415: { gang: 'Bit Bandits' },
            416: { gang: 'Nexus Nomads' },
            417: { gang: 'Rogue Riders' },
            418: { gang: 'Nexus Nomads' },
            419: { gang: 'Talisman Tribe' },
            420: { gang: 'Bit Bandits' },
            421: { gang: 'Talisman Tribe' },
            422: { gang: 'Talisman Tribe' },
            423: { gang: 'Rogue Riders' },
            424: { gang: 'Rogue Riders' },
            425: { gang: 'Rogue Riders' },
            426: { gang: 'Bit Bandits' },
            427: { gang: 'Talisman Tribe' },
            428: { gang: 'Rogue Riders' },
            429: { gang: 'Bit Bandits' },
            430: { gang: 'Nexus Nomads' },
            431: { gang: 'Nexus Nomads' },
            432: { gang: 'Rogue Riders' },
            433: { gang: 'Talisman Tribe' },
            434: { gang: 'Talisman Tribe' },
            435: { gang: 'Rogue Riders' },
            436: { gang: 'Nexus Nomads' },
            437: { gang: 'Rogue Riders' },
            438: { gang: 'Bit Bandits' },
            439: { gang: 'Talisman Tribe' },
            440: { gang: 'Rogue Riders' },
            441: { gang: 'Rogue Riders' },
            442: { gang: 'Bit Bandits' },
            443: { gang: 'Rogue Riders' },
            444: { gang: 'Bit Bandits' },
            445: { gang: 'Bit Bandits' },
            446: { gang: 'Talisman Tribe' },
            447: { gang: 'Rogue Riders' },
            448: { gang: 'Nexus Nomads' },
            449: { gang: 'Nexus Nomads' },
            450: { gang: 'Nexus Nomads' },
            451: { gang: 'Bit Bandits' },
            452: { gang: 'Bit Bandits' },
            453: { gang: 'Nexus Nomads' },
            454: { gang: 'Nexus Nomads' },
            455: { gang: 'Nexus Nomads' },
            456: { gang: 'Bit Bandits' },
            457: { gang: 'Rogue Riders' },
            458: { gang: 'Talisman Tribe' },
            459: { gang: 'Rogue Riders' },
            460: { gang: 'Talisman Tribe' },
            461: { gang: 'Nexus Nomads' },
            462: { gang: 'Talisman Tribe' },
            463: { gang: 'Bit Bandits' },
            464: { gang: 'Rogue Riders' },
            465: { gang: 'Nexus Nomads' },
            466: { gang: 'Talisman Tribe' },
            467: { gang: 'Nexus Nomads' },
            468: { gang: 'Talisman Tribe' },
            469: { gang: 'Nexus Nomads' },
            470: { gang: 'Bit Bandits' },
            471: { gang: 'Talisman Tribe' },
            472: { gang: 'Bit Bandits' },
            473: { gang: 'Nexus Nomads' },
            474: { gang: 'Rogue Riders' },
            475: { gang: 'Nexus Nomads' },
            476: { gang: 'Rogue Riders' },
            477: { gang: 'Talisman Tribe' },
            478: { gang: 'Talisman Tribe' },
            479: { gang: 'Bit Bandits' },
            480: { gang: 'Bit Bandits' },
            481: { gang: 'Nexus Nomads' },
            482: { gang: 'Rogue Riders' },
            483: { gang: 'Talisman Tribe' },
            484: { gang: 'Talisman Tribe' },
            485: { gang: 'Nexus Nomads' },
            486: { gang: 'Rogue Riders' },
            487: { gang: 'Nexus Nomads' },
            488: { gang: 'Nexus Nomads' },
            489: { gang: 'Talisman Tribe' },
            490: { gang: 'Rogue Riders' },
            491: { gang: 'Nexus Nomads' },
            492: { gang: 'Rogue Riders' },
            493: { gang: 'Bit Bandits' },
            494: { gang: 'Nexus Nomads' },
            495: { gang: 'Nexus Nomads' },
            496: { gang: 'Nexus Nomads' },
            497: { gang: 'Bit Bandits' },
            498: { gang: 'Bit Bandits' },
            499: { gang: 'Nexus Nomads' },
            500: { gang: 'Bit Bandits' },
            501: { gang: 'Rogue Riders' },
            502: { gang: 'Talisman Tribe' },
            503: { gang: 'Rogue Riders' },
            504: { gang: 'Talisman Tribe' },
            505: { gang: 'Nexus Nomads' },
            506: { gang: 'Rogue Riders' },
            507: { gang: 'Bit Bandits' },
            508: { gang: 'Talisman Tribe' },
            509: { gang: 'Rogue Riders' },
            510: { gang: 'Rogue Riders' },
            511: { gang: 'Rogue Riders' },
            512: { gang: 'Rogue Riders' },
            513: { gang: 'Rogue Riders' },
            514: { gang: 'Nexus Nomads' },
            515: { gang: 'Rogue Riders' },
            516: { gang: 'Rogue Riders' },
            517: { gang: 'Nexus Nomads' },
            518: { gang: 'Bit Bandits' },
            519: { gang: 'Nexus Nomads' },
            520: { gang: 'Nexus Nomads' },
            521: { gang: 'Nexus Nomads' },
            522: { gang: 'Nexus Nomads' },
            523: { gang: 'Nexus Nomads' },
            524: { gang: 'Bit Bandits' },
            525: { gang: 'Bit Bandits' },
            526: { gang: 'Bit Bandits' },
            527: { gang: 'Nexus Nomads' },
            528: { gang: 'Rogue Riders' },
            529: { gang: 'Nexus Nomads' },
            530: { gang: 'Bit Bandits' },
            531: { gang: 'Talisman Tribe' },
            532: { gang: 'Rogue Riders' },
            533: { gang: 'Talisman Tribe' },
            534: { gang: 'Rogue Riders' },
            535: { gang: 'Rogue Riders' },
            536: { gang: 'Rogue Riders' },
            537: { gang: 'Talisman Tribe' },
            538: { gang: 'Bit Bandits' },
            539: { gang: 'Nexus Nomads' },
            540: { gang: 'Rogue Riders' },
            541: { gang: 'Bit Bandits' },
            542: { gang: 'Nexus Nomads' },
            543: { gang: 'Nexus Nomads' },
            544: { gang: 'Talisman Tribe' },
            545: { gang: 'Nexus Nomads' },
            546: { gang: 'Rogue Riders' },
            547: { gang: 'Rogue Riders' },
            548: { gang: 'Rogue Riders' },
            549: { gang: 'Talisman Tribe' },
            550: { gang: 'Rogue Riders' },
            551: { gang: 'Talisman Tribe' },
            552: { gang: 'Rogue Riders' },
            553: { gang: 'Bit Bandits' },
            554: { gang: 'Rogue Riders' },
            555: { gang: 'Bit Bandits' },
            556: { gang: 'Talisman Tribe' },
            557: { gang: 'Bit Bandits' },
            558: { gang: 'Rogue Riders' },
            559: { gang: 'Nexus Nomads' },
            560: { gang: 'Talisman Tribe' },
            561: { gang: 'Talisman Tribe' },
            562: { gang: 'Rogue Riders' },
            563: { gang: 'Bit Bandits' },
            564: { gang: 'Nexus Nomads' },
            565: { gang: 'Bit Bandits' },
            566: { gang: 'Nexus Nomads' },
            567: { gang: 'Rogue Riders' },
            568: { gang: 'Talisman Tribe' },
            569: { gang: 'Rogue Riders' },
            570: { gang: 'Nexus Nomads' },
            571: { gang: 'Rogue Riders' },
            572: { gang: 'Bit Bandits' },
            573: { gang: 'Bit Bandits' },
            574: { gang: 'Rogue Riders' },
            575: { gang: 'Bit Bandits' },
            576: { gang: 'Nexus Nomads' },
            577: { gang: 'Rogue Riders' },
            578: { gang: 'Talisman Tribe' },
            579: { gang: 'Bit Bandits' },
            580: { gang: 'Talisman Tribe' },
            581: { gang: 'Bit Bandits' },
            582: { gang: 'Bit Bandits' },
            583: { gang: 'Bit Bandits' },
            584: { gang: 'Talisman Tribe' },
            585: { gang: 'Nexus Nomads' },
            586: { gang: 'Rogue Riders' },
            587: { gang: 'Talisman Tribe' },
            588: { gang: 'Nexus Nomads' },
            589: { gang: 'Nexus Nomads' },
            590: { gang: 'Nexus Nomads' },
            591: { gang: 'Talisman Tribe' },
            592: { gang: 'Nexus Nomads' },
            593: { gang: 'Bit Bandits' },
            594: { gang: 'Nexus Nomads' },
            595: { gang: 'Rogue Riders' },
            596: { gang: 'Nexus Nomads' },
            597: { gang: 'Bit Bandits' },
            598: { gang: 'Bit Bandits' },
            599: { gang: 'Talisman Tribe' },
            600: { gang: 'Bit Bandits' },
            601: { gang: 'Bit Bandits' },
            602: { gang: 'Bit Bandits' },
            603: { gang: 'Bit Bandits' },
            604: { gang: 'Bit Bandits' },
            605: { gang: 'Talisman Tribe' },
            606: { gang: 'Rogue Riders' },
            607: { gang: 'Nexus Nomads' },
            608: { gang: 'Talisman Tribe' },
            609: { gang: 'Talisman Tribe' },
            610: { gang: 'Talisman Tribe' },
            611: { gang: 'Bit Bandits' },
            612: { gang: 'Rogue Riders' },
            613: { gang: 'Nexus Nomads' },
            614: { gang: 'Nexus Nomads' },
            615: { gang: 'Nexus Nomads' },
            616: { gang: 'Bit Bandits' },
            617: { gang: 'Rogue Riders' },
            618: { gang: 'Talisman Tribe' },
            619: { gang: 'Nexus Nomads' },
            620: { gang: 'Rogue Riders' },
            621: { gang: 'Rogue Riders' },
            622: { gang: 'Rogue Riders' },
            623: { gang: 'Bit Bandits' },
            624: { gang: 'Talisman Tribe' },
            625: { gang: 'Talisman Tribe' },
            626: { gang: 'Bit Bandits' },
            627: { gang: 'Talisman Tribe' },
            628: { gang: 'Nexus Nomads' },
            629: { gang: 'Talisman Tribe' },
            630: { gang: 'Bit Bandits' },
            631: { gang: 'Talisman Tribe' },
            632: { gang: 'Nexus Nomads' },
            633: { gang: 'Talisman Tribe' },
            634: { gang: 'Nexus Nomads' },
            635: { gang: 'Talisman Tribe' },
            636: { gang: 'Rogue Riders' },
            637: { gang: 'Talisman Tribe' },
            638: { gang: 'Talisman Tribe' },
            639: { gang: 'Rogue Riders' },
            640: { gang: 'Rogue Riders' },
            641: { gang: 'Rogue Riders' },
            642: { gang: 'Rogue Riders' },
            643: { gang: 'Bit Bandits' },
            644: { gang: 'Nexus Nomads' },
            645: { gang: 'Bit Bandits' },
            646: { gang: 'Bit Bandits' },
            647: { gang: 'Nexus Nomads' },
            648: { gang: 'Rogue Riders' },
            649: { gang: 'Talisman Tribe' },
            650: { gang: 'Talisman Tribe' },
            651: { gang: 'Nexus Nomads' },
            652: { gang: 'Talisman Tribe' },
            653: { gang: 'Talisman Tribe' },
            654: { gang: 'Talisman Tribe' },
            655: { gang: 'Talisman Tribe' },
            656: { gang: 'Bit Bandits' },
            657: { gang: 'Talisman Tribe' },
            658: { gang: 'Nexus Nomads' },
            659: { gang: 'Talisman Tribe' },
            660: { gang: 'Rogue Riders' },
            661: { gang: 'Bit Bandits' },
            662: { gang: 'Rogue Riders' },
            663: { gang: 'Rogue Riders' },
            664: { gang: 'Bit Bandits' },
            665: { gang: 'Bit Bandits' },
            666: { gang: 'Rogue Riders' },
            667: { gang: 'Talisman Tribe' },
            668: { gang: 'Nexus Nomads' },
            669: { gang: 'Talisman Tribe' },
            670: { gang: 'Talisman Tribe' },
            671: { gang: 'Rogue Riders' },
            672: { gang: 'Rogue Riders' },
            673: { gang: 'Bit Bandits' },
            674: { gang: 'Bit Bandits' },
            675: { gang: 'Bit Bandits' },
            676: { gang: 'Bit Bandits' },
            677: { gang: 'Bit Bandits' },
            678: { gang: 'Rogue Riders' },
            679: { gang: 'Talisman Tribe' },
            680: { gang: 'Rogue Riders' },
            681: { gang: 'Talisman Tribe' },
            682: { gang: 'Bit Bandits' },
            683: { gang: 'Bit Bandits' },
            684: { gang: 'Nexus Nomads' },
            685: { gang: 'Talisman Tribe' },
            686: { gang: 'Nexus Nomads' },
            687: { gang: 'Nexus Nomads' },
            688: { gang: 'Rogue Riders' },
            689: { gang: 'Talisman Tribe' },
            690: { gang: 'Talisman Tribe' },
            691: { gang: 'Talisman Tribe' },
            692: { gang: 'Talisman Tribe' },
            693: { gang: 'Talisman Tribe' },
            694: { gang: 'Bit Bandits' },
            695: { gang: 'Rogue Riders' },
            696: { gang: 'Bit Bandits' },
            697: { gang: 'Bit Bandits' },
            698: { gang: 'Talisman Tribe' },
            699: { gang: 'Bit Bandits' },
            700: { gang: 'Bit Bandits' },
            701: { gang: 'Bit Bandits' },
            702: { gang: 'Rogue Riders' },
            703: { gang: 'Bit Bandits' },
            704: { gang: 'Rogue Riders' },
            705: { gang: 'Talisman Tribe' },
            706: { gang: 'Rogue Riders' },
            707: { gang: 'Talisman Tribe' },
            708: { gang: 'Bit Bandits' },
            709: { gang: 'Nexus Nomads' },
            710: { gang: 'Talisman Tribe' },
            711: { gang: 'Rogue Riders' },
            712: { gang: 'Rogue Riders' },
            713: { gang: 'Nexus Nomads' },
            714: { gang: 'Rogue Riders' },
            715: { gang: 'Bit Bandits' },
            716: { gang: 'Talisman Tribe' },
            717: { gang: 'Bit Bandits' },
            718: { gang: 'Nexus Nomads' },
            719: { gang: 'Bit Bandits' },
            720: { gang: 'Talisman Tribe' },
            721: { gang: 'Bit Bandits' },
            722: { gang: 'Talisman Tribe' },
            723: { gang: 'Talisman Tribe' },
            724: { gang: 'Nexus Nomads' },
            725: { gang: 'Rogue Riders' },
            726: { gang: 'Rogue Riders' },
            727: { gang: 'Nexus Nomads' },
            728: { gang: 'Bit Bandits' },
            729: { gang: 'Rogue Riders' },
            730: { gang: 'Nexus Nomads' },
            731: { gang: 'Talisman Tribe' },
            732: { gang: 'Nexus Nomads' },
            733: { gang: 'Talisman Tribe' },
            734: { gang: 'Bit Bandits' },
            735: { gang: 'Bit Bandits' },
            736: { gang: 'Talisman Tribe' },
            737: { gang: 'Nexus Nomads' },
            738: { gang: 'Talisman Tribe' },
            739: { gang: 'Talisman Tribe' },
            740: { gang: 'Rogue Riders' },
            741: { gang: 'Talisman Tribe' },
            742: { gang: 'Rogue Riders' },
            743: { gang: 'Nexus Nomads' },
            744: { gang: 'Rogue Riders' },
            745: { gang: 'Bit Bandits' },
            746: { gang: 'Nexus Nomads' },
            747: { gang: 'Bit Bandits' },
            748: { gang: 'Talisman Tribe' },
            749: { gang: 'Bit Bandits' },
            750: { gang: 'Nexus Nomads' },
            751: { gang: 'Talisman Tribe' },
            752: { gang: 'Nexus Nomads' },
            753: { gang: 'Nexus Nomads' },
            754: { gang: 'Nexus Nomads' },
            755: { gang: 'Nexus Nomads' },
            756: { gang: 'Talisman Tribe' },
            757: { gang: 'Talisman Tribe' },
            758: { gang: 'Bit Bandits' },
            759: { gang: 'Bit Bandits' },
            760: { gang: 'Nexus Nomads' },
            761: { gang: 'Nexus Nomads' },
            762: { gang: 'Rogue Riders' },
            763: { gang: 'Nexus Nomads' },
            764: { gang: 'Nexus Nomads' },
            765: { gang: 'Bit Bandits' },
            766: { gang: 'Talisman Tribe' },
            767: { gang: 'Talisman Tribe' },
            768: { gang: 'Bit Bandits' },
            769: { gang: 'Bit Bandits' },
            770: { gang: 'Nexus Nomads' },
            771: { gang: 'Rogue Riders' },
            772: { gang: 'Nexus Nomads' },
            773: { gang: 'Rogue Riders' },
            774: { gang: 'Talisman Tribe' },
            775: { gang: 'Rogue Riders' },
            776: { gang: 'Bit Bandits' },
            777: { gang: 'Bit Bandits' },
            778: { gang: 'Talisman Tribe' },
            779: { gang: 'Bit Bandits' },
            780: { gang: 'Bit Bandits' },
            781: { gang: 'Bit Bandits' },
            782: { gang: 'Nexus Nomads' },
            783: { gang: 'Talisman Tribe' },
            784: { gang: 'Nexus Nomads' },
            785: { gang: 'Rogue Riders' },
            786: { gang: 'Nexus Nomads' },
            787: { gang: 'Rogue Riders' },
            788: { gang: 'Bit Bandits' },
            789: { gang: 'Rogue Riders' },
            790: { gang: 'Rogue Riders' },
            791: { gang: 'Nexus Nomads' },
            792: { gang: 'Rogue Riders' },
            793: { gang: 'Bit Bandits' },
            794: { gang: 'Bit Bandits' },
            795: { gang: 'Talisman Tribe' },
            796: { gang: 'Rogue Riders' },
            797: { gang: 'Rogue Riders' },
            798: { gang: 'Talisman Tribe' },
            799: { gang: 'Bit Bandits' },
            800: { gang: 'Bit Bandits' },
            801: { gang: 'Nexus Nomads' },
            802: { gang: 'Nexus Nomads' },
            803: { gang: 'Nexus Nomads' },
            804: { gang: 'Rogue Riders' },
            805: { gang: 'Bit Bandits' },
            806: { gang: 'Rogue Riders' },
            807: { gang: 'Talisman Tribe' },
            808: { gang: 'Nexus Nomads' },
            809: { gang: 'Bit Bandits' },
            810: { gang: 'Bit Bandits' },
            811: { gang: 'Rogue Riders' },
            812: { gang: 'Bit Bandits' },
            813: { gang: 'Talisman Tribe' },
            814: { gang: 'Bit Bandits' },
            815: { gang: 'Talisman Tribe' },
            816: { gang: 'Talisman Tribe' },
            817: { gang: 'Bit Bandits' },
            818: { gang: 'Talisman Tribe' },
            819: { gang: 'Nexus Nomads' },
            820: { gang: 'Rogue Riders' },
            821: { gang: 'Nexus Nomads' },
            822: { gang: 'Nexus Nomads' },
            823: { gang: 'Nexus Nomads' },
            824: { gang: 'Bit Bandits' },
            825: { gang: 'Bit Bandits' },
            826: { gang: 'Talisman Tribe' },
            827: { gang: 'Rogue Riders' },
            828: { gang: 'Nexus Nomads' },
            829: { gang: 'Rogue Riders' },
            830: { gang: 'Nexus Nomads' },
            831: { gang: 'Talisman Tribe' },
            832: { gang: 'Rogue Riders' },
            833: { gang: 'Talisman Tribe' },
            834: { gang: 'Rogue Riders' },
            835: { gang: 'Bit Bandits' },
            836: { gang: 'Bit Bandits' },
            837: { gang: 'Rogue Riders' },
            838: { gang: 'Nexus Nomads' },
            839: { gang: 'Bit Bandits' },
            840: { gang: 'Rogue Riders' },
            841: { gang: 'Bit Bandits' },
            842: { gang: 'Rogue Riders' },
            843: { gang: 'Bit Bandits' },
            844: { gang: 'Nexus Nomads' },
            845: { gang: 'Talisman Tribe' },
            846: { gang: 'Talisman Tribe' },
            847: { gang: 'Talisman Tribe' },
            848: { gang: 'Talisman Tribe' },
            849: { gang: 'Talisman Tribe' },
            850: { gang: 'Bit Bandits' },
            851: { gang: 'Talisman Tribe' },
            852: { gang: 'Talisman Tribe' },
            853: { gang: 'Nexus Nomads' },
            854: { gang: 'Nexus Nomads' },
            855: { gang: 'Bit Bandits' },
            856: { gang: 'Nexus Nomads' },
            857: { gang: 'Talisman Tribe' },
            858: { gang: 'Talisman Tribe' },
            859: { gang: 'Rogue Riders' },
            860: { gang: 'Rogue Riders' },
            861: { gang: 'Rogue Riders' },
            862: { gang: 'Talisman Tribe' },
            863: { gang: 'Talisman Tribe' },
            864: { gang: 'Talisman Tribe' },
            865: { gang: 'Rogue Riders' },
            866: { gang: 'Rogue Riders' },
            867: { gang: 'Nexus Nomads' },
            868: { gang: 'Rogue Riders' },
            869: { gang: 'Bit Bandits' },
            870: { gang: 'Rogue Riders' },
            871: { gang: 'Rogue Riders' },
            872: { gang: 'Rogue Riders' },
            873: { gang: 'Talisman Tribe' },
            874: { gang: 'Bit Bandits' },
            875: { gang: 'Nexus Nomads' },
            876: { gang: 'Talisman Tribe' },
            877: { gang: 'Rogue Riders' },
            878: { gang: 'Nexus Nomads' },
            879: { gang: 'Nexus Nomads' },
            880: { gang: 'Rogue Riders' },
            881: { gang: 'Nexus Nomads' },
            882: { gang: 'Talisman Tribe' },
            883: { gang: 'Nexus Nomads' },
            884: { gang: 'Talisman Tribe' },
            885: { gang: 'Nexus Nomads' },
            886: { gang: 'Nexus Nomads' },
            887: { gang: 'Bit Bandits' },
            888: { gang: 'Rogue Riders' },
            889: { gang: 'Rogue Riders' },
            890: { gang: 'Rogue Riders' },
            891: { gang: 'Rogue Riders' },
            892: { gang: 'Bit Bandits' },
            893: { gang: 'Bit Bandits' },
            894: { gang: 'Rogue Riders' },
            895: { gang: 'Nexus Nomads' },
            896: { gang: 'Nexus Nomads' },
            897: { gang: 'Nexus Nomads' },
            898: { gang: 'Nexus Nomads' },
            899: { gang: 'Rogue Riders' },
            900: { gang: 'Bit Bandits' },
            901: { gang: 'Talisman Tribe' },
            902: { gang: 'Talisman Tribe' },
            903: { gang: 'Talisman Tribe' },
            904: { gang: 'Rogue Riders' },
            905: { gang: 'Bit Bandits' },
            906: { gang: 'Bit Bandits' },
            907: { gang: 'Nexus Nomads' },
            908: { gang: 'Rogue Riders' },
            909: { gang: 'Talisman Tribe' },
            910: { gang: 'Talisman Tribe' },
            911: { gang: 'Nexus Nomads' },
            912: { gang: 'Rogue Riders' },
            913: { gang: 'Nexus Nomads' },
            914: { gang: 'Rogue Riders' },
            915: { gang: 'Talisman Tribe' },
            916: { gang: 'Bit Bandits' },
            917: { gang: 'Bit Bandits' },
            918: { gang: 'Bit Bandits' },
            919: { gang: 'Talisman Tribe' },
            920: { gang: 'Bit Bandits' },
            921: { gang: 'Bit Bandits' },
            922: { gang: 'Bit Bandits' },
            923: { gang: 'Rogue Riders' },
            924: { gang: 'Rogue Riders' },
            925: { gang: 'Rogue Riders' },
            926: { gang: 'Talisman Tribe' },
            927: { gang: 'Rogue Riders' },
            928: { gang: 'Rogue Riders' },
            929: { gang: 'Talisman Tribe' },
            930: { gang: 'Bit Bandits' },
            931: { gang: 'Rogue Riders' },
            932: { gang: 'Nexus Nomads' },
            933: { gang: 'Rogue Riders' },
            934: { gang: 'Bit Bandits' },
            935: { gang: 'Nexus Nomads' },
            936: { gang: 'Bit Bandits' },
            937: { gang: 'Talisman Tribe' },
            938: { gang: 'Rogue Riders' },
            939: { gang: 'Rogue Riders' },
            940: { gang: 'Rogue Riders' },
            941: { gang: 'Bit Bandits' },
            942: { gang: 'Talisman Tribe' },
            943: { gang: 'Bit Bandits' },
            944: { gang: 'Rogue Riders' },
            945: { gang: 'Rogue Riders' },
            946: { gang: 'Bit Bandits' },
            947: { gang: 'Nexus Nomads' },
            948: { gang: 'Rogue Riders' },
            949: { gang: 'Rogue Riders' },
            950: { gang: 'Rogue Riders' },
            951: { gang: 'Talisman Tribe' },
            952: { gang: 'Nexus Nomads' },
            953: { gang: 'Nexus Nomads' },
            954: { gang: 'Talisman Tribe' },
            955: { gang: 'Talisman Tribe' },
            956: { gang: 'Bit Bandits' },
            957: { gang: 'Nexus Nomads' },
            958: { gang: 'Bit Bandits' },
            959: { gang: 'Rogue Riders' },
            960: { gang: 'Rogue Riders' },
            961: { gang: 'Bit Bandits' },
            962: { gang: 'Nexus Nomads' },
            963: { gang: 'Talisman Tribe' },
            964: { gang: 'Bit Bandits' },
            965: { gang: 'Talisman Tribe' },
            966: { gang: 'Bit Bandits' },
            967: { gang: 'Nexus Nomads' },
            968: { gang: 'Bit Bandits' },
            969: { gang: 'Bit Bandits' },
            970: { gang: 'Talisman Tribe' },
            971: { gang: 'Bit Bandits' },
            972: { gang: 'Nexus Nomads' },
            973: { gang: 'Rogue Riders' },
            974: { gang: 'Nexus Nomads' },
            975: { gang: 'Talisman Tribe' },
            976: { gang: 'Talisman Tribe' },
            977: { gang: 'Bit Bandits' },
            978: { gang: 'Bit Bandits' },
            979: { gang: 'Rogue Riders' },
            980: { gang: 'Nexus Nomads' },
            981: { gang: 'Nexus Nomads' },
            982: { gang: 'Rogue Riders' },
            983: { gang: 'Nexus Nomads' },
            984: { gang: 'Bit Bandits' },
            985: { gang: 'Nexus Nomads' },
            986: { gang: 'Talisman Tribe' },
            987: { gang: 'Talisman Tribe' },
            988: { gang: 'Bit Bandits' },
            989: { gang: 'Rogue Riders' },
            990: { gang: 'Nexus Nomads' },
            991: { gang: 'Rogue Riders' },
            992: { gang: 'Rogue Riders' },
            993: { gang: 'Rogue Riders' },
            994: { gang: 'Talisman Tribe' },
            995: { gang: 'Bit Bandits' },
            996: { gang: 'Nexus Nomads' },
            997: { gang: 'Talisman Tribe' },
            998: { gang: 'Bit Bandits' },
            999: { gang: 'Talisman Tribe' },
            1000: { gang: 'Rogue Riders' },
        };



        // Helper functions for metadata
        function getRidersByGang(gangName) {
        return Object.keys(METADATA)
            .filter(id => METADATA[id].gang === gangName)
            .map(id => parseInt(id));
        }

        function setupTournamentRiders() {
            const gangs = ['Bit Bandits', 'Nexus Nomads', 'Rogue Riders', 'Talisman Tribe'];
            const leftBracket = [];  // Will become P1-P4
            const rightBracket = []; // Will become P5-P8
            const usedRiderIds = new Set();
            
            gangs.forEach(gangName => {
                const gangRiders = getRidersByGang(gangName);
                const shuffled = gangRiders.sort(() => Math.random() - 0.5);
                
                // Pick first unique rider for left bracket
                let leftRider = shuffled[0];
                usedRiderIds.add(leftRider);
                leftBracket.push(leftRider);
                
                // Pick second unique rider for right bracket
                let rightRider = shuffled.find(id => !usedRiderIds.has(id));
                if (rightRider) {
                    usedRiderIds.add(rightRider);
                    rightBracket.push(rightRider);
                } else {
                    rightRider = shuffled[1];
                    usedRiderIds.add(rightRider);
                    rightBracket.push(rightRider);
                }
            });
            
            // Shuffle within each bracket for randomness
            const shuffledLeft = leftBracket.sort(() => Math.random() - 0.5);
            const shuffledRight = rightBracket.sort(() => Math.random() - 0.5);
            
            // ✅ FIX: Return left bracket first (P1-P4), then right bracket (P5-P8)
            return [...shuffledLeft, ...shuffledRight];
        }


        // Game State
        // 4 Gangs from metadata: Bit Bandits, Nexus Nomads, Rogue Riders, Talisman Tribe
        const GANG_COLORS = {
            'Bit Bandits': '#f9ca24',      // Yellow
            'Nexus Nomads': '#45b7d1',     // Blue
            'Rogue Riders': '#ff6b6b',     // Red
            'Talisman Tribe': '#6c5ce7'    // Purple
        };

        // Gang Icons (Google Drive hosted)
        //const GANG_ICONS = {
            //'Nexus Nomads': 'https://drive.google.com/uc?export=view&id=1QA6L7Y2gZfpq7NsTAFkGCZvyy9MDwal1',
            //'Rogue Riders': 'https://drive.google.com/uc?export=view&id=1QwJ71ZMW88br2TJia_UrpipStkUXOauK',
            //'Talisman Tribe': 'https://drive.google.com/uc?export=view&id=12UTMmJpRBkubZyJ2MrNvt62tY2VP6Zb1',
            //'Bit Bandits': 'https://drive.google.com/uc?export=view&id=11dBDZF7rWnhAwEmPrnJHTJYPOMVKpvZP'
        //};

        // Gang Icons (Google Drive hosted) - FIXED URLs
        const GANG_ICONS = {
            'Nexus Nomads': 'https://lh3.googleusercontent.com/d/1QA6L7Y2gZfpq7NsTAFkGCZvyy9MDwal1',
            'Rogue Riders': 'https://lh3.googleusercontent.com/d/1QwJ71ZMW88br2TJia_UrpipStkUXOauK',
            'Talisman Tribe': 'https://lh3.googleusercontent.com/d/12UTMmJpRBkubZyJ2MrNvt62tY2VP6Zb1',
            'Bit Bandits': 'https://lh3.googleusercontent.com/d/11dBDZF7rWnhAwEmPrnJHTJYPOMVKpvZP'
        };

        // Helper function to get gang icon HTML
        function getGangIconHTML(gangName, size = '30px') {
            const iconUrl = GANG_ICONS[gangName];
            if (!iconUrl) return '';
            return `<img src="${iconUrl}" alt="${gangName}" style="width: ${size}; height: ${size}; object-fit: contain; margin-right: 8px; vertical-align: middle;">`;
        }

        // Will be populated by setupTournamentRiders()
        let COLORS = [];
        let GANG_NAMES = [];

        const PRIMARY_BOOSTS = [
            { id: 'none', name: 'None', description: 'No boost' },
            { id: 'brawler', name: 'Brawler', description: 'If opponent wins first roll, nullify and reroll' },
            { id: 'guardian', name: 'Guardian', description: 'Win first roll → auto-win second roll' },
            { id: 'nosdemon', name: 'NosDemon', description: 'Start match with 1-0 lead' },
            { id: 'revive', name: 'Revive', description: 'Lose match → replay final roll' },
            { id: 'saboteur', name: 'Saboteur', description: 'Choose any gang prize (visual only)' }
        ];

        const SECONDARY_BOOSTS = [
            { id: 'none', name: 'None', description: 'No secondary boost' },
            { id: 'doubleplay', name: 'Double Play', description: 'Use primary boost twice' },
            { id: 'thief', name: 'Thief', description: 'Steal opponent boost at match start' },
            { id: 'scavenger', name: 'Scavenger', description: 'Steal opponent boost on match win' }
        ];

        const ROUND_RESTRICTIONS = [
            { id: 'any', name: 'Any Round' },
            { id: 'round1', name: 'Round 1 Only' },
            { id: 'round2', name: 'Round 2 Only' },
            { id: 'finals', name: 'Finals Only' }
        ];

        let players = [];
        let currentRound = 1;
        let currentMatchIndex = 0;
        let matches = [];
        let boostNotificationEl;
        let rollHistory = []; // Track last 10 rolls

        // Initialize game
        function initGame() {
            // Setup tournament riders (2 from each gang)
            const selectedRiderIds = setupTournamentRiders();
            
            // Populate COLORS and GANG_NAMES arrays based on selected riders
            COLORS = [];
            GANG_NAMES = [];
            selectedRiderIds.forEach(riderId => {
                const gangName = METADATA[riderId]?.gang || 'Bit Bandits';
                GANG_NAMES.push(gangName);
                COLORS.push(GANG_COLORS[gangName] || '#ffffff');
            });
            
            // Create 8 players
            players = [];
            for (let i = 0; i < 8; i++) {
                const riderId = String(selectedRiderIds[i]);
                const gangName = GANG_NAMES[i];
                const gangColor = COLORS[i];

                players.push({
                    id: i,
                    name: `Player ${i + 1}`,
                    riderId: riderId,
                    color: gangColor,  // ✅ Now has actual gang color!
                    gang: gangName,    // ✅ Now has actual gang name!
                    initials: `P${i + 1}`,
                    primaryBoost: 'none',
                    secondaryBoost: 'none',
                    roundRestriction: 'any',
                    usedBoosts: [],
                    boostUseCount: {}
                });
            }

            renderBoostSetup();
        }

        // Render boost setup screen
        function renderBoostSetup() {
            const list = document.getElementById('playerBoostList');
            let html = '';

            players.forEach(player => {
                html += `<div class="player-boost-item">`;
                    html += `
                    <div class="player-boost-avatar" style="border-color: ${player.color}">
                        <img src="${getPlayerNFTUrl(player.riderId)}" alt="${player.name}">
                    </div>
                `;
                html += `<div class="player-boost-name">
                    ${getGangIconHTML(player.gang, '24px')}
                    ${player.name} #${player.riderId}
                </div>`;

                // Primary Boost
                html += `<div class="boost-column">`;
                html += `<div class="boost-label">Primary Boost</div>`;
                html += `<select class="boost-select primary-boost" data-player-id="${player.id}">`;
                PRIMARY_BOOSTS.forEach(boost => {
                    const selected = player.primaryBoost === boost.id ? 'selected' : '';
                    html += `<option value="${boost.id}" ${selected}>${boost.name}</option>`;
                });
                html += `</select>`;
                html += `</div>`;

                // Secondary Boost (filtered based on primary boost)
                html += `<div class="boost-column">`;
                html += `<div class="boost-label">Secondary Boost</div>`;
                html += `<select class="boost-select secondary secondary-boost" data-player-id="${player.id}">`;

                const hasPrimaryBoost = player.primaryBoost !== 'none';
                const hasSaboteur = player.primaryBoost === 'saboteur';
                SECONDARY_BOOSTS.forEach(boost => {
                    // Double Play only for players with primary boost (except Saboteur)
                    // Thief and Scavenger only for players without primary boost
                    if (boost.id === 'none' || 
                    (boost.id === 'doubleplay' && hasPrimaryBoost && !hasSaboteur) ||
                    (boost.id === 'thief' && !hasPrimaryBoost) ||
                    (boost.id === 'scavenger' && !hasPrimaryBoost)) {
                    const selected = player.secondaryBoost === boost.id ? 'selected' : '';
                    html += `<option value="${boost.id}" ${selected}>${boost.name}</option>`;
                    }
                });
                html += `</select>`;
                html += `</div>`;

                // Round Restriction
                html += `<div class="boost-column">`;
                html += `<div class="boost-label">Active In</div>`;
                html += `<select class="boost-select round-restriction" data-player-id="${player.id}">`;
                ROUND_RESTRICTIONS.forEach(restriction => {
                    const selected = player.roundRestriction === restriction.id ? 'selected' : '';
                    html += `<option value="${restriction.id}" ${selected}>${restriction.name}</option>`;
                });
                html += `</select>`;
                html += `</div>`;

                html += `</div>`;
            });

            list.innerHTML = html;

            // Add event listeners
            document.querySelectorAll('.primary-boost').forEach(select => {
                select.addEventListener('change', function() {
                    const playerId = parseInt(this.dataset.playerId);
                    players[playerId].primaryBoost = this.value;

                    // Reset secondary boost if it's no longer valid
                    const hasPrimaryBoost = this.value !== 'none';
                    const hasSaboteur = this.value === 'saboteur';

                    if (hasPrimaryBoost && (players[playerId].secondaryBoost === 'thief' || players[playerId].secondaryBoost === 'scavenger')) {
                        players[playerId].secondaryBoost = 'none';
                    } else if (!hasPrimaryBoost && players[playerId].secondaryBoost === 'doubleplay') {
                        players[playerId].secondaryBoost = 'none';
                    } else if (hasSaboteur && players[playerId].secondaryBoost === 'doubleplay') {
                        players[playerId].secondaryBoost = 'none';
                    }

                    // Re-render to update secondary boost options
                    renderBoostSetup();
                });
            });

            document.querySelectorAll('.secondary-boost').forEach(select => {
                select.addEventListener('change', function() {
                    const playerId = parseInt(this.dataset.playerId);
                    players[playerId].secondaryBoost = this.value;
                });
            });

            document.querySelectorAll('.round-restriction').forEach(select => {
                select.addEventListener('change', function() {
                    const playerId = parseInt(this.dataset.playerId);
                    players[playerId].roundRestriction = this.value;
                });
            });
        }

        // Randomize boosts
        document.getElementById('randomizeButton').addEventListener('click', function() {
            // Reset all boosts
            players.forEach(p => {
                p.primaryBoost = 'none';
                p.secondaryBoost = 'none';
                p.roundRestriction = 'any';
            });

            // Get available primary boosts (excluding 'none')
            const availablePrimary = PRIMARY_BOOSTS.filter(b => b.id !== 'none').map(b => b.id);

            // Shuffle players to randomize who gets primary boosts
            const shuffledPlayerIndices = [...Array(players.length).keys()].sort(() => Math.random() - 0.5);

            // Assign unique primary boosts to random players
            for (let i = 0; i < availablePrimary.length; i++) {
                const playerIndex = shuffledPlayerIndices[i];
                players[playerIndex].primaryBoost = availablePrimary[i];
            }

            // Assign secondary boosts with rules:
            // - Double Play: Only to players WITH a primary boost (except Saboteur)
            // - Thief/Scavenger: Only to players WITHOUT a primary boost
            players.forEach(player => {
                const hasPrimaryBoost = player.primaryBoost !== 'none';
                const hasSaboteur = player.primaryBoost === 'saboteur';

                if (hasPrimaryBoost && !hasSaboteur) {
                    // 50% chance to get Double Play (not for Saboteur)
                    if (Math.random() > 0.5) {
                        player.secondaryBoost = 'doubleplay';
                    }
                } else if (!hasPrimaryBoost) {
                    // 50% chance to get Thief or Scavenger
                    const rand = Math.random();
                    if (rand > 0.66) {
                        player.secondaryBoost = 'thief';
                    } else if (rand > 0.33) {
                        player.secondaryBoost = 'scavenger';
                    }
                    // else: stays 'none'
                }
            });

            // Randomly assign round restrictions
            const restrictions = ROUND_RESTRICTIONS.map(r => r.id);
            players.forEach(player => {
                player.roundRestriction = restrictions[Math.floor(Math.random() * restrictions.length)];
            });

            renderBoostSetup();
        });

        // Generate interference for the tournament
        function generateInterference() {
            const interference = {
                decryptor: null,
                cosmicStorm: null
            };

            // 50% chance for Decryptor Interference
            if (Math.random() < 0.5) {
                const round = Math.random() < 0.5 ? 1 : 2;
                const matchCount = round === 1 ? 4 : 2;
                const matchIndex = Math.floor(Math.random() * matchCount);
                const reduction = round === 1 ? 1 : 2;

                interference.decryptor = {
                    round: round,
                    matchIndex: matchIndex,
                    reduction: reduction
                };

                console.log(`Decryptor Interference: Round ${round}, Match ${matchIndex + 1}, -${reduction} rounds`);
            }

            // 50% chance for Cosmic Storm (only targets matches with primary boosts)
            if (Math.random() < 0.5) {
                const round = Math.random() < 0.5 ? 1 : 2;

                // Get matches for this round
                let potentialMatches = [];
                if (round === 1) {
                    potentialMatches = [
                        { index: 0, players: [players[0], players[1]] },
                        { index: 1, players: [players[2], players[3]] },
                        { index: 2, players: [players[4], players[5]] },
                        { index: 3, players: [players[6], players[7]] }
                    ];
                } else {
                    // For Round 2, we don't know winners yet, so just pick randomly
                    // We'll validate when the round starts
                    potentialMatches = [
                        { index: 0, players: [] },
                        { index: 1, players: [] }
                    ];
                }

                // Filter matches where at least one player has a primary boost
                const validMatches = potentialMatches.filter(m => {
                    if (m.players.length === 0) return true; // Round 2 - can't check yet
                    return m.players.some(p => p.primaryBoost !== 'none');
                });

                if (validMatches.length > 0) {
                    const selectedMatch = validMatches[Math.floor(Math.random() * validMatches.length)];

                    interference.cosmicStorm = {
                        round: round,
                        matchIndex: selectedMatch.index
                    };

                    console.log(`Cosmic Storm: Round ${round}, Match ${selectedMatch.index + 1}`);
                } else {
                    console.log('Cosmic Storm: No valid targets (no primary boosts)');
                }
            }

            return interference;
        }

        let tournamentInterference = null;

        // Start tournament
        document.getElementById('startTournamentButton').addEventListener('click', function() {
            console.log('Starting tournament with boosts:', players.map(p => ({ 
                name: p.name, 
                primary: p.primaryBoost, 
                secondary: p.secondaryBoost,
                rounds: p.roundRestriction
            })));

            // Generate interference
            tournamentInterference = generateInterference();

            // Hide setup, show game
            document.getElementById('boostSetupScreen').classList.remove('show');
            document.getElementById('gameArea').classList.add('show');

            // Setup Round 1 matches
            currentRound = 1;
            currentMatchIndex = 0;

            matches = [
                { player1: players[0], player2: players[1], bestOf: 3, scores: [], winner: null },
                { player1: players[2], player2: players[3], bestOf: 3, scores: [], winner: null },
                { player1: players[4], player2: players[5], bestOf: 3, scores: [], winner: null },
                { player1: players[6], player2: players[7], bestOf: 3, scores: [], winner: null }
            ];

            // Apply Decryptor Interference to Round 1 if applicable
            if (tournamentInterference.decryptor && tournamentInterference.decryptor.round === 1) {
                const idx = tournamentInterference.decryptor.matchIndex;
                const reduction = tournamentInterference.decryptor.reduction;
                matches[idx].bestOf -= reduction;
                matches[idx].decryptorInterference = reduction;
                console.log(`Applied Decryptor to Match ${idx + 1}: Best of ${matches[idx].bestOf}`);
            }

            // Apply Cosmic Storm to Round 1 if applicable
            if (tournamentInterference.cosmicStorm && tournamentInterference.cosmicStorm.round === 1) {
                const idx = tournamentInterference.cosmicStorm.matchIndex;
                matches[idx].cosmicStorm = true;
                console.log(`Applied Cosmic Storm to Match ${idx + 1}`);
            }

            boostNotificationEl = document.getElementById('boostNotification');

            // Setup reset button listeners (now that game area is visible)
            setupResetButtons();

            // Show splash first (boosts should only process when START MATCH is pressed)
            clearReplayHistory();
            showMatchStartSplash();

            renderBracket();
            updateMatchInfo();
        });

        // Setup reset button event listeners
        function setupResetButtons() {
            const undoBtn = document.getElementById('undoRollButton');
            const resetMatchBtn = document.getElementById('resetMatchButton');
            const resetRoundBtn = document.getElementById('resetRoundButton');

            // Check if buttons exist before adding listeners
            if (!undoBtn || !resetMatchBtn || !resetRoundBtn) {
                console.warn('Reset buttons not found in DOM yet', {undoBtn, resetMatchBtn, resetRoundBtn});
                return;
            }

            // ✅ FIX: Check if listeners already attached (prevent duplicates)
            if (undoBtn.dataset.listenerAttached === 'true') {
                console.log('Reset button listeners already attached, skipping');
                return;
            }

            console.log('Reset buttons found and listeners attached');

            // Undo Last Roll
            undoBtn.addEventListener('click', function() {
                if (!confirm('Undo the last dice roll?')) return;

                const match = matches[currentMatchIndex];
                if (match.scores.length === 0) {
                    alert('No rolls to undo!');
                    return;
                }

                // Remove last score
                const lastScore = match.scores.pop();

                // If it was a NosDemon auto-win, restore the boost
                if (lastScore.result === 'nosdemon') {
                    const player = lastScore.player === 1 ? match.player1 : match.player2;
                    if (player.boostUseCount['nosdemon']) {
                        player.boostUseCount['nosdemon']--;
                    }
                }

                // Reset dice and message
                document.getElementById('die1').textContent = '?';
                document.getElementById('die2').textContent = '?';
                document.getElementById('resultMessage').textContent = '';

                renderBracket();
                updateMatchInfo();

                console.log('Undid last roll');
            });

            // Reset Current Match
            resetMatchBtn.addEventListener('click', function() {
                if (!confirm('Reset the current match? All progress in this match will be lost.')) return;

                const match = matches[currentMatchIndex];

                // Reset match scores
                match.scores = [];
                match.winner = null;

                // Reset boosts used in this match for both players
                match.player1.boostUseCount = {};
                match.player2.boostUseCount = {};

                // Reset dice and message
                document.getElementById('die1').textContent = '?';
                document.getElementById('die2').textContent = '?';
                document.getElementById('resultMessage').textContent = '';

                // Re-process match start boosts (NosDemon, etc.)
                processMatchStartBoosts();

                renderBracket();
                updateMatchInfo();

                console.log('Reset current match');
            });

            // Reset Current Round
            resetRoundBtn.addEventListener('click', function() {
                if (!confirm('Reset the entire current round? All matches in this round will be reset.')) return;

                // Reset all matches in current round
                matches.forEach(match => {
                    match.scores = [];
                    match.winner = null;

                    // Reset boost usage for all players in this round
                    match.player1.boostUseCount = {};
                    match.player2.boostUseCount = {};
                });

                // Go back to first match of the round
                currentMatchIndex = 0;

                // Reset dice and message
                document.getElementById('die1').textContent = '?';
                document.getElementById('die2').textContent = '?';
                document.getElementById('resultMessage').textContent = '';

                // Re-process match start boosts for first match
                processMatchStartBoosts();

                renderBracket();
                updateMatchInfo();

                console.log('Reset current round');
            });

            // ✅ FIX: Mark buttons as having listeners attached
            undoBtn.dataset.listenerAttached = 'true';
            resetMatchBtn.dataset.listenerAttached = 'true';
            resetRoundBtn.dataset.listenerAttached = 'true';

        }

        // Check if boost is active in current round
        function isBoostActiveInRound(player, roundNum, boostId = null) {
            // Scavenged boosts work in any round (no restriction)
            if (boostId && player.scavengedBoost === boostId) {
                console.log(`${player.name} scavenged boost ${boostId} is active in all rounds`);
                return true;
            }

            // Stolen boosts work in any round (no restriction)
            if (boostId && player.stolenBoost === boostId) {
                console.log(`${player.name} stolen boost ${boostId} is active in all rounds`);
                return true;
            }

            const restriction = player.roundRestriction;
            const hasDoublePlay = player.secondaryBoost === 'doubleplay';

            // Check if this is the primary boost (Double Play only extends primary boost)
            const isPrimaryBoost = boostId && player.primaryBoost === boostId;

            // Base active rounds based on restriction
            let activeRounds = [];

            // Match the actual dropdown values: "round1", "round2", "round3"
            if (restriction === 'round1') {
                activeRounds = [1];
            } else if (restriction === 'round2') {
                activeRounds = [2, 3];  // Starts in Round 2, active in Round 2 and 3
            } else if (restriction === 'round3') {
                activeRounds = [3];  // Only active in Round 3 (Finals)
            } else if (restriction === 'any' || !restriction) {
                activeRounds = [1, 2, 3];  // All rounds (no restriction)
            }

            // Double Play extends primary boost by 1 round (if not already at max)
            if (hasDoublePlay && isPrimaryBoost && activeRounds.length < 3) {
                const maxRound = Math.max(...activeRounds);
                if (maxRound < 3) {
                    activeRounds.push(maxRound + 1);
                }
            }

            return activeRounds.includes(roundNum);
        }

        // Get all active boosts for a player
        function getActiveBoosts(player) {
            const boosts = [];
            if (player.primaryBoost !== 'none') boosts.push(player.primaryBoost);
            if (player.secondaryBoost !== 'none') boosts.push(player.secondaryBoost);
            return boosts;
        }

        // Process boosts that activate at match start
        function processMatchStartBoosts() {
            const match = matches[currentMatchIndex];
    
            // ADD THIS SAFETY CHECK
            if (!match) {
                console.error('No match found at current index');
                return;
            }
            
            // ADD THIS SAFETY CHECK
            if (!match.scores) {
                match.scores = [];
            }
            
            clearReplayHistory(); // ✅ Clear replay history for new match
            
            const p1 = match.player1;
            const p2 = match.player2;

            // Check for interference and trigger effects

            // Cosmic Storm Effect
            if (match.cosmicStorm) {
                console.log('Cosmic Storm active - triggering effects');
                
                // Play sound
                playCosmicStormSound();
                
                // Trigger screen flash animation
                document.body.classList.add('cosmic-storm-active');
                setTimeout(() => {
                    document.body.classList.remove('cosmic-storm-active');
                }, 1500);
                
                // Show notification
                showEnhancedNotification('⚡ COSMIC STORM! All boosts disabled! ⚡', 4000);
            }

            // Decryptor Interference Effect
            if (match.decryptorInterference) {
                console.log(`Decryptor Interference active - ${match.decryptorInterference} round(s) reduced`);
                
                // Play sound
                playDecryptorSound();
                
                // Trigger match box glitch animation
                const matchElement = document.querySelector('.match.active');
                if (matchElement) {
                    matchElement.classList.add('decryptor-active');
                    setTimeout(() => {
                        matchElement.classList.remove('decryptor-active');
                    }, 1200);
                }
                
                // Show notification
                showEnhancedNotification(`⚠️ DECRYPTOR INTERFERENCE! Match reduced by ${match.decryptorInterference} round(s)! ⚠️`, 4000);
            }

            console.log(`Match start: ${p1.name} vs ${p2.name} (Round ${currentRound})`);
            console.log(`${p1.name} boosts:`, getActiveBoosts(p1), 'Active:', isBoostActiveInRound(p1, currentRound));
            console.log(`${p2.name} boosts:`, getActiveBoosts(p2), 'Active:', isBoostActiveInRound(p2, currentRound));

            // Thief: Steal opponent's primary boost
            if (hasActiveBoost(p1, 'thief') && p2.primaryBoost !== 'none' && !isBoostFullyUsed(p2, p2.primaryBoost)) {
                const stolenBoost = p2.primaryBoost;
                // Add stolen boost as a temporary boost
                p1.stolenBoost = stolenBoost;
                markBoostFullyUsed(p2, stolenBoost);
                useBoost(p1, 'thief');
                showBoostNotification(`${p1.name} steals ${stolenBoost.toUpperCase()} from ${p2.name}!`, 'thief', p1);
                console.log(`${p1.name} stole ${stolenBoost} from ${p2.name}`);
            } else if (hasActiveBoost(p2, 'thief') && p1.primaryBoost !== 'none' && !isBoostFullyUsed(p1, p1.primaryBoost)) {
                const stolenBoost = p1.primaryBoost;
                p2.stolenBoost = stolenBoost;
                markBoostFullyUsed(p1, stolenBoost);
                useBoost(p2, 'thief');
                showBoostNotification(`${p2.name} steals ${stolenBoost.toUpperCase()} from ${p1.name}!`, 'thief', p2);
                console.log(`${p2.name} stole ${stolenBoost} from ${p1.name}`);
            }

            // Helper: Check if boost is original (primary) - used for priority
            function isOriginalBoost(player, boostId) {
                return player.primaryBoost === boostId;
            }

            // NosDemon: Start with 1-0 lead
            // Priority: Original boost > Scavenged/Stolen boost
            const p1HasNosDemon = hasActiveBoost(p1, 'nosdemon');
            const p2HasNosDemon = hasActiveBoost(p2, 'nosdemon');

            if (p1HasNosDemon && p2HasNosDemon) {
                // Both have NosDemon - original takes priority
                const p1Original = isOriginalBoost(p1, 'nosdemon');
                const p2Original = isOriginalBoost(p2, 'nosdemon');

                if (p1Original && !p2Original) {
                    // P1 has original, P2 has scavenged - P1 wins
                    const nosDemonScore = { roll1: 0, roll2: 0, winner: 1, result: 'nosdemon' };
                    match.scores.push(nosDemonScore);
                    addToReplayHistory('roll', nosDemonScore);
                    useBoost(p1, 'nosdemon');
                    showBoostNotification(`${p1.name} starts with NOSDEMON! (1-0) [${p2.name}'s scavenged NosDemon blocked]`, 'nosdemon', p1);
                    console.log(`${p1.name} used NosDemon (original) - ${p2.name}'s scavenged NosDemon blocked`);
                } else if (p2Original && !p1Original) {
                    // P2 has original, P1 has scavenged - P2 wins
                    const nosDemonScore = { roll1: 0, roll2: 0, winner: 2, result: 'nosdemon' };
                    match.scores.push(nosDemonScore);
                    addToReplayHistory('roll', nosDemonScore);
                    useBoost(p2, 'nosdemon');
                    showBoostNotification(`${p2.name} starts with NOSDEMON! (0-1) [${p1.name}'s scavenged NosDemon blocked]`, 'nosdemon', p2);
                    console.log(`${p2.name} used NosDemon (original) - ${p1.name}'s scavenged NosDemon blocked`);
                } else if (p1Original && p2Original) {
                    // Both have original - they cancel out (no one gets advantage)
                    showBoostNotification(`Both players have NOSDEMON! They cancel out.`);
                    console.log(`Both players have original NosDemon - cancelled out`);
                } else {
                    // Both have scavenged - P1 position takes priority
                    const nosDemonScore = { roll1: 0, roll2: 0, winner: 1, result: 'nosdemon' };
                    match.scores.push(nosDemonScore);
                    addToReplayHistory('roll', nosDemonScore);
                    useBoost(p1, 'nosdemon');
                    showBoostNotification(`${p1.name} starts with NOSDEMON! (1-0) [Both scavenged, P1 priority]`, 'nosdemon', p1);
                    console.log(`${p1.name} used NosDemon (scavenged, P1 priority)`);
                }
            } else if (p1HasNosDemon) {
                // Only P1 has NosDemon
                const nosDemonScore = { roll1: 0, roll2: 0, winner: 1, result: 'nosdemon' };
                match.scores.push(nosDemonScore);
                addToReplayHistory('roll', nosDemonScore);
                useBoost(p1, 'nosdemon');
                showBoostNotification(`${p1.name} starts with NOSDEMON! (1-0)`, 'nosdemon', p1);
                console.log(`${p1.name} used NosDemon - starting 1-0`);
            } else if (p2HasNosDemon) {
                // Only P2 has NosDemon
                const nosDemonScore = { roll1: 0, roll2: 0, winner: 2, result: 'nosdemon' };
                match.scores.push(nosDemonScore);
                addToReplayHistory('roll', nosDemonScore);
                useBoost(p2, 'nosdemon');
                showBoostNotification(`${p2.name} starts with NOSDEMON! (0-1)`, 'nosdemon', p2);
                console.log(`${p2.name} used NosDemon - starting 0-1`);
            }
        }

        // Splash / replay flow state
        let splashType = null;            // 'start' | 'end'
        let replayReturnTarget = null;    // null | 'end_splash'

        // Show match start splash screen
        function showMatchStartSplash() {
            const match = matches[currentMatchIndex];
            const splash = document.getElementById('matchSplashScreen');
            const title = document.getElementById('splashTitle');
            const matchInfo = document.getElementById('splashMatchInfo');
            const playersContainer = document.getElementById('splashPlayers');
            const continueBtn = document.getElementById('splashContinueBtn');
            const replayBtn = document.getElementById('splashReplayBtn');

            title.textContent = 'MATCH START';
            matchInfo.textContent = `Round ${currentRound} - Match ${currentMatchIndex + 1}`;
            
            // Hide replay button for start splash
            replayBtn.style.display = 'none';
            
            playersContainer.innerHTML = `
                <div class="splash-player">
                    <div class="splash-nft-container" style="border-color: ${match.player1.color}">
                        <img class="splash-nft-img" src="${getPlayerNFTUrl(match.player1.riderId)}" alt="${match.player1.name}">
                    </div>
                    <div class="splash-player-name" style="color: ${match.player1.color}">${match.player1.name}</div>
                    <div class="splash-gang-name" style="color: ${match.player1.color}">
                        <img src="${GANG_ICONS[match.player1.gang]}" alt="${match.player1.gang}" style="width: 24px; height: 24px; vertical-align: middle; margin-right: 8px;">
                        ${match.player1.gang || ''}
                    </div>
                    <div class="splash-player-id">#${match.player1.riderId}</div>
                </div>
                <div class="splash-vs">VS</div>
                <div class="splash-player">
                    <div class="splash-nft-container" style="border-color: ${match.player2.color}">
                        <img class="splash-nft-img" src="${getPlayerNFTUrl(match.player2.riderId)}" alt="${match.player2.name}">
                    </div>
                    <div class="splash-player-name" style="color: ${match.player2.color}">${match.player2.name}</div>
                    <div class="splash-gang-name" style="color: ${match.player2.color}">
                        <img src="${GANG_ICONS[match.player2.gang]}" alt="${match.player2.gang}" style="width: 24px; height: 24px; vertical-align: middle; margin-right: 8px;">
                        ${match.player2.gang || ''}
                    </div>
                    <div class="splash-player-id">#${match.player2.riderId}</div>
                </div>
            `;
            
            continueBtn.textContent = 'START MATCH ▶';
            continueBtn.onclick = function() {
                splash.classList.remove('show');
                // Process boosts like NosDemon only when the match actually starts
                processMatchStartBoosts();

                // ✅ RE-ENABLE THE ROLL BUTTON
                document.getElementById('rollButton').disabled = false;

                renderBracket();
                updateMatchInfo();
            };
            
            splash.classList.add('show');
        }

        // Show match end splash screen
        function showMatchEndSplash(winner) {
            const match = matches[currentMatchIndex];
            if (!winner) return;

            const splash = document.getElementById('matchSplashScreen');
            const title = document.getElementById('splashTitle');
            const matchInfo = document.getElementById('splashMatchInfo');
            const playersContainer = document.getElementById('splashPlayers');
            const continueBtn = document.getElementById('splashContinueBtn');
            const replayBtn = document.getElementById('splashReplayBtn');
            
            const loser = match.player1.id === winner.id ? match.player2 : match.player1;

            // Safety check to prevent the "null" error
            if (!splash || !title || !matchInfo || !playersContainer) {
                console.error('Splash elements not found');
                return;
            }

            title.textContent = 'MATCH COMPLETE';
            matchInfo.textContent = `Round ${currentRound} - Match ${currentMatchIndex + 1}`;
            
            // Always show players in bracket order (player1 left, player2 right)
            const leftPlayer = match.player1;
            const rightPlayer = match.player2;
            const leftIsWinner = winner.id === leftPlayer.id;
            const rightIsWinner = winner.id === rightPlayer.id;

            playersContainer.innerHTML = `
                <div class="splash-player" style="opacity: ${leftIsWinner ? '1' : '0.8'};">
                    <div class="splash-nft-container" style="border-color: ${leftPlayer.color}; position: relative;">
                    <img class="splash-nft-img" src="${getPlayerNFTUrl(leftPlayer.riderId)}" alt="${leftPlayer.name}">
                    ${!leftIsWinner ? '<div class="splash-loser-overlay"><div class="splash-loser-x">X</div></div>' : ''}
                    </div>
                    <div class="splash-player-name" style="color: ${leftPlayer.color}">${leftPlayer.name}</div>
                    <div class="splash-gang-name" style="color: ${leftPlayer.color}">
                        <img src="${GANG_ICONS[leftPlayer.gang]}" alt="${leftPlayer.gang}" style="width: 24px; height: 24px; vertical-align: middle; margin-right: 8px;">
                        ${leftPlayer.gang || ''}
                    </div>
                    <div class="splash-player-id">#${leftPlayer.riderId}</div>
                </div>
                <div class="splash-vs">VS</div>
                <div class="splash-player" style="opacity: ${rightIsWinner ? '1' : '0.8'};">
                    <div class="splash-nft-container" style="border-color: ${rightPlayer.color}; position: relative;">
                    <img class="splash-nft-img" src="${getPlayerNFTUrl(rightPlayer.riderId)}" alt="${rightPlayer.name}">
                    ${!rightIsWinner ? '<div class="splash-loser-overlay"><div class="splash-loser-x">X</div></div>' : ''}
                    </div>
                    <div class="splash-player-name" style="color: ${rightPlayer.color}">${rightPlayer.name}</div>
                    <div class="splash-gang-name" style="color: ${rightPlayer.color}">
                        <img src="${GANG_ICONS[rightPlayer.gang]}" alt="${rightPlayer.gang}" style="width: 24px; height: 24px; vertical-align: middle; margin-right: 8px;">
                        ${rightPlayer.gang || ''}
                    </div>
                    <div class="splash-player-id">#${rightPlayer.riderId}</div>
                </div>
            `;
            
            if (replayBtn) replayBtn.style.display = 'inline-block';
            
            continueBtn.textContent = 'CONTINUE ▶';
            continueBtn.onclick = function() {
                splash.classList.remove('show');
                
                // Check if this is the finals
                if (currentRound === 3) {
                    // Finals complete - show winner screen
                    showWinner(match.winner);
                } else {
                    // Regular match - advance to next match
                    advanceMatch();
                }
            };
            
            splash.classList.add('show');
        }

        function hideSplashScreen() {
            const splash = document.getElementById('matchSplashScreen');
            const title = document.getElementById('splashTitle').textContent;
            
            // If this is a "Match Complete" splash, keep it visible during transition
            if (title.includes('COMPLETE')) {
                // Don't hide the splash yet - let advanceMatch handle the transition
                // This keeps the screen covered during round transitions
                return;
            }
            
            // This was a "Match Start" splash, so we just hide it and enable the game
            splash.classList.remove('show');
            document.getElementById('rollButton').disabled = false;
            renderBracket();
            updateMatchInfo();
        }

        function replayFromEndSplash() {
            // Only intended for match-end splash
            replayReturnTarget = 'end_splash';

            const match = matches[currentMatchIndex];
            const winner = match ? match.winner : null;
            if (!winner) {
                console.warn('replayFromEndSplash called but no winner set for this match');
            }

            // Hide splash so replay controls are clickable
            const splash = document.getElementById('matchSplashScreen');
            if (splash) {
                splash.classList.remove('show');
            }

            enterReplayMode();
        }

        // Get boost display name
        function getBoostDisplayName(boostName) {
            const names = {
                'brawler': 'Brawler',
                'guardian': 'Guardian',
                'nosdemon': 'NosDemon',
                'revive': 'Revive',
                'thief': 'Thief',
                'scavenger': 'Scavenger',
                'doubleplay': 'Double Play',
                'saboteur': 'Saboteur',
                'none': 'None'
            };
            return names[boostName] || boostName;
        }

        // Get boost color class for CSS
        function getBoostColorClass(boostName) {
            const colorMap = {
                'brawler': 'boost-yellow',
                'guardian': 'boost-yellow',
                'nosdemon': 'boost-yellow',
                'revive': 'boost-yellow',
                'thief': 'boost-yellow',
                'scavenger': 'boost-yellow',
                'doubleplay': 'boost-green',
                'saboteur': 'boost-purple'
            };
            return colorMap[boostName] || 'boost-yellow';
        }

        // Check if player has an active (not fully used) boost
        function hasActiveBoost(player, boostId) {
            // Check for Cosmic Storm
            const match = matches[currentMatchIndex];
            if (match && match.cosmicStorm) {
                console.log(`${player.name} boost ${boostId} blocked by Cosmic Storm`);
                return false; // All boosts disabled
            }

            // Check if player has this boost (primary, secondary, stolen, or scavenged)
            const hasBoost = player.primaryBoost === boostId || 
                           player.secondaryBoost === boostId || 
                           player.stolenBoost === boostId ||
                           player.scavengedBoost === boostId;

            if (!hasBoost) {
                console.log(`${player.name} does not have boost ${boostId}`);
                return false;
            }

            // Check if boost is fully used
            const fullyUsed = isBoostFullyUsed(player, boostId);
            if (fullyUsed) {
                console.log(`${player.name} boost ${boostId} is fully used (${player.boostUseCount[boostId]} uses)`);
                return false;
            }

            // Check if boost is active in current round
            const activeInRound = isBoostActiveInRound(player, currentRound, boostId);
            console.log(`${player.name} boost ${boostId} active in Round ${currentRound}? ${activeInRound} (restriction: ${player.roundRestriction})`);
            return activeInRound;
        }

        // Check if boost is fully used (considering Double Play)
        function isBoostFullyUsed(player, boostId) {
            const useCount = player.boostUseCount[boostId] || 0;
            const hasDoublePlay = player.secondaryBoost === 'doubleplay' && boostId !== 'thief';
            const maxUses = hasDoublePlay ? 2 : 1;
            return useCount >= maxUses;
        }

        // Mark boost as fully used (both uses exhausted)
        function markBoostFullyUsed(player, boostId) {
            if (!player.usedBoosts.includes(boostId)) {
                player.usedBoosts.push(boostId);
            }
            const hasDoublePlay = player.secondaryBoost === 'doubleplay';
            const maxUses = hasDoublePlay ? 2 : 1;
            player.boostUseCount[boostId] = maxUses;
        }

        // Use boost (increment use count)
        function useBoost(player, boostId) {
            player.boostUseCount[boostId] = (player.boostUseCount[boostId] || 0) + 1;
            const hasDoublePlay = player.secondaryBoost === 'doubleplay' && boostId !== 'thief';
            const maxUses = hasDoublePlay ? 2 : 1;

            console.log(`${player.name} used ${boostId} (${player.boostUseCount[boostId]}/${maxUses})`);

            // If fully used, mark as used
            if (player.boostUseCount[boostId] >= maxUses) {
                if (!player.usedBoosts.includes(boostId)) {
                    player.usedBoosts.push(boostId);
                }
                // If this was the second use, also mark Double Play as used
                if (hasDoublePlay && player.boostUseCount[boostId] === 2) {
                    if (!player.usedBoosts.includes('doubleplay')) {
                        player.usedBoosts.push('doubleplay');
                    }
                }
            }
        }

        function checkReviveProc(loserIndex) {
            const match = matches[currentMatchIndex];
            const loser = loserIndex === 0 ? match.player1 : match.player2;
            
            // Check if loser has unused Revive boost
            if (hasActiveBoost(loser, 'revive')) {
                useBoost(loser, 'revive');
                const useCount = loser.boostUseCount['revive'];
                const hasDoublePlay = loser.secondaryBoost === 'doubleplay';
                const maxUses = hasDoublePlay ? 2 : 1;
                
                showBoostNotification(`${loser.name} activates REVIVE! ${useCount}/${maxUses} Replaying final round...`, 'revive', loser);
                
                // Remove last score
                match.scores.pop();
                match.winner = null;
                
                const resultMsg = document.getElementById('resultMessage');
                resultMsg.textContent = 'REVIVE activated! Roll again...';
                
                renderBracket();
                updateMatchInfo();
                
                console.log(`${loser.name} used Revive (${useCount}/${maxUses})`);
                return true; // Revive proc'd
            }
            
            return false; // No revive available
        }

       // Show boost notification (ENHANCED IN V2)
        function showBoostNotification(message, boostName = null, player = null) {
            // Use enhanced notification system
            showEnhancedNotification(message, 3000);
            
            // Trigger animation if boost and player are provided
            if (boostName && player) {
                // Add small delay to ensure DOM is rendered
                setTimeout(() => {
                    const playerEl = findPlayerElement(player);
                    console.log(`Attempting animation for ${player.name} with boost ${boostName}`);
                    console.log(`Player element found:`, playerEl);
                    if (playerEl) {
                    triggerBoostAnimation(playerEl, boostName);
                    } else {
                    console.log(`Could not find player element for ${player.name}`);
                    }
                }, 100);
            }
            
            // Legacy support for old notification element
            boostNotificationEl.innerHTML = `<div class="boost-notification">${message}</div>`;
            setTimeout(() => {
                boostNotificationEl.innerHTML = '';
            }, 3000);
        }

        // Render tournament bracket
        function renderBracket() {
            if (bracketViewMode === 'full') {
                renderFullBracket();
                return;
            }
            const bracket = document.getElementById('currentMatchView');
            const currentMatch = matches[currentMatchIndex];

            let html = `<div class="round-title">Round ${currentRound} - Match ${currentMatchIndex + 1}</div>`;
            html += `<div class="match-info">Best of ${currentMatch.bestOf}</div>`;

            // Current match
            const hasInterference = currentMatch.decryptorInterference || currentMatch.cosmicStorm;
            const hasGangTakeover = currentMatch.gangTakeover;
            const gangColor = currentMatch.gangColor || '#00d4ff';

            let matchClasses = 'match active';
            if (hasInterference) matchClasses += ' interference';
            if (hasGangTakeover) matchClasses += ' gang-takeover';

            // Set CSS variable for gang color
            const gangColorStyle = hasGangTakeover ? `style="--gang-color: ${gangColor}; border-color: ${gangColor};"` : '';

            html += `<div class="${matchClasses}" ${gangColorStyle}>`;

            // Show interference notifications
            if (currentMatch.decryptorInterference) {
                html += `<div class="interference-notice decryptor">⚠️ DECRYPTOR INTERFERENCE: -${currentMatch.decryptorInterference} round(s)</div>`;
            }
            if (currentMatch.cosmicStorm) {
                html += `<div class="interference-notice storm">⚡ COSMIC STORM: All boosts disabled!</div>`;
            }
            if (currentMatch.gangTakeover) {
                const gangName = currentMatch.player1.gang.toUpperCase();
                html += `<div class="gang-takeover-notice" style="background: rgba(${hexToRgb(currentMatch.gangColor)}, 0.3); border: 3px solid ${currentMatch.gangColor}; color: ${currentMatch.gangColor};">🔥 GANG TAKEOVER: ${gangName} 🔥</div>`;
            }

            html += renderPlayer(currentMatch.player1, currentMatch, true);
            html += renderPlayer(currentMatch.player2, currentMatch, false);
            html += `</div>`;

            // Other matches in current round
            matches.forEach((match, idx) => {
                if (idx !== currentMatchIndex) {
                    const completed = match.winner !== null;
                    html += `<div class="match ${completed ? 'completed' : ''}">`;
                    html += renderPlayer(match.player1, match, true);
                    html += renderPlayer(match.player2, match, false);
                    html += `</div>`;
                }
            });

            bracket.innerHTML = html;
            
            // Attach tooltip listeners to boost badges (V2 Enhancement)
            attachTooltipListeners();
        }

        // Render individual player
        function renderPlayer(player, match, isPlayer1) {
            const isWinner = match.winner && match.winner.id === player.id;
            const isLoser = match.winner && match.winner.id !== player.id;

            let html = `<div class="player ${isWinner ? 'winner' : ''} ${isLoser ? 'loser' : ''}">`;
                html += `
                <div class="avatar" style="border-color: ${player.color}">
                    <img src="${getPlayerNFTUrl(player.riderId)}" alt="${player.name}">
                </div>
            `;
            html += `<div class="player-name">
                ${getGangIconHTML(player.gang, '20px')}
                ${player.name} <span class="rider-id">#${player.riderId}</span>
            </div>`;

            // Render boosts
            const allBoosts = [];
            if (player.primaryBoost !== 'none') allBoosts.push(player.primaryBoost);
            if (player.secondaryBoost !== 'none') allBoosts.push(player.secondaryBoost);
            if (player.stolenBoost) allBoosts.push(player.stolenBoost);
            if (player.scavengedBoost) allBoosts.push(player.scavengedBoost);

            if (allBoosts.length > 0) {
                html += `<div class="player-boosts">`;
                allBoosts.forEach(boostId => {
                    const isFullyUsed = isBoostFullyUsed(player, boostId);
                    const isActive = isBoostActiveInRound(player, currentRound, boostId);
                    const boostName = [...PRIMARY_BOOSTS, ...SECONDARY_BOOSTS].find(b => b.id === boostId)?.name || boostId;
                    const useCount = player.boostUseCount[boostId] || 0;
                    const hasDoublePlay = player.secondaryBoost === 'doubleplay' && boostId !== 'thief' && boostId !== 'doubleplay';
                    const maxUses = hasDoublePlay ? 2 : 1;

                    let displayName = boostName;
                    if (hasDoublePlay && useCount > 0 && useCount < maxUses) {
                        displayName = `${boostName} (${useCount}/${maxUses})`;
                    }

                    const classes = ['boost-badge'];

                    // Add color class based on boost type
                    classes.push(getBoostColorClass(boostId));

                    // Add special class for Saboteur
                    if (boostId === 'saboteur') {
                        classes.push('saboteur');
                    }

                    // Check for Cosmic Storm
                    const match = matches[currentMatchIndex];
                    const cosmicStormActive = match && match.cosmicStorm;

                    // Priority: Cosmic Storm > Fully used > Wrong round > Active
                    if (cosmicStormActive) {
                        classes.push('disabled');
                    } else if (isFullyUsed) {
                        classes.push('used');
                    } else if (!isActive) {
                        classes.push('inactive');
                    }
                    // If partially used and in correct round, keep it yellow (no extra class)

                    if (player.stolenBoost === boostId) classes.push('stolen');

                    const boostDesc = [...PRIMARY_BOOSTS, ...SECONDARY_BOOSTS].find(b => b.id === boostId)?.description || '';
                    html += `<span class="${classes.join(' ')}" title="${boostDesc}" data-boost-name="${boostName}">${displayName}</span>`;
                });
                html += `</div>`;
            }

            html += `<div class="score-dots">`;

            // Render score dots based on match.scores in order
            match.scores.forEach((score, index) => {
                if (index >= match.bestOf) return; // Don't render sudden death dots
                
                if (score.result === 'tie') {
                    html += `<div class="dot tie"></div>`;
                } else if ((isPlayer1 && score.winner === 1) || (!isPlayer1 && score.winner === 2)) {
                    html += `<div class="dot win"></div>`;
                } else {
                    html += `<div class="dot loss"></div>`;
                }
            });

            // Fill remaining empty dots up to bestOf
            for (let i = match.scores.length; i < match.bestOf; i++) {
                html += `<div class="dot"></div>`;
            }

            html += `</div></div>`;
            return html;
        }

        // Update match info display
        function updateMatchInfo() {
            const match = matches[currentMatchIndex];
            const info = document.getElementById('matchInfo');
            const p1Label = document.getElementById('player1Label');
            const p2Label = document.getElementById('player2Label');

            const p1Wins = match.scores.filter(s => s.winner === 1).length;
            const p2Wins = match.scores.filter(s => s.winner === 2).length;
            const totalRounds = match.scores.length;
            const inSuddenDeath = totalRounds >= match.bestOf && p1Wins === p2Wins;

            if (inSuddenDeath) {
                info.innerHTML = `<span class="sudden-death-indicator">⚡ SUDDEN DEATH ⚡</span><br>Next score wins!`;
            } else {
                info.textContent = `Round ${currentRound} - Match ${currentMatchIndex + 1} | Best of ${match.bestOf} | Score: ${p1Wins}-${p2Wins}`;
            }

            p1Label.textContent = match.player1.name + ' #' + match.player1.riderId;
            p2Label.textContent = match.player2.name + ' #' + match.player2.riderId;
        }

        // Roll dice (V2 ENHANCED WITH SOUND)
        document.getElementById('rollButton').addEventListener('click', function() {
            const die1 = document.getElementById('die1');
            const die2 = document.getElementById('die2');
            const button = document.getElementById('rollButton');
            const resultMsg = document.getElementById('resultMessage');

            button.disabled = true;
            die1.classList.add('rolling');
            die2.classList.add('rolling');
            resultMsg.textContent = '';

            // Play dice roll sound
            playDiceRollSound();

            // Animate rolling
            let rollCount = 0;
            const rollInterval = setInterval(() => {
                die1.textContent = Math.floor(Math.random() * 6) + 1;
                die2.textContent = Math.floor(Math.random() * 6) + 1;
                rollCount++;

                if (rollCount >= 10) {
                    clearInterval(rollInterval);

                    // Final roll
                    const roll1 = Math.floor(Math.random() * 6) + 1;
                    const roll2 = Math.floor(Math.random() * 6) + 1;

                    die1.textContent = roll1;
                    die2.textContent = roll2;

                    setTimeout(() => {
                        die1.classList.remove('rolling');
                        die2.classList.remove('rolling');
                        processRoll(roll1, roll2);
                        button.disabled = false;
                    }, 500);
                }
            }, 50);
        });

        document.getElementById('continueButton').addEventListener('click', function() {
            hideContinueButton();
            // Instead of calling advanceMatch directly, show the end splash
            // which then handles the transition
            showMatchEndSplash();
        });

        // Process dice roll result
        function processRoll(roll1, roll2) {
            const match = matches[currentMatchIndex];
            const resultMsg = document.getElementById('resultMessage');
            const p1 = match.player1;
            const p2 = match.player2;

            let winner = 0;
            let message = '';

            if (roll1 > roll2) {
                winner = 1;
                message = `${p1.name} wins this round!`;
                playWinSound();
            } else if (roll2 > roll1) {
                winner = 2;
                message = `${p2.name} wins this round!`;
                playWinSound();
            } else {
                winner = 0;
                message = "It's a tie!";
                playTieSound();
                gameStats.totalTies++;  // NEW - Track tie
            }

            // Check for Brawler (opponent wins first roll → nullify and reroll)
            // Only check actual wins, not ties
            // First roll = no previous rolls that were actual dice rolls (exclude nosdemon, guardian, etc.)
            const actualRolls = match.scores.filter(s => s.result === 'win' || s.result === 'tie');
            const isFirstRoll = actualRolls.length === 0;
            if (isFirstRoll && winner !== 0) {
                // Player 2 won → check if Player 1 has Brawler
                if (winner === 2 && hasActiveBoost(p1, 'brawler')) {
                    useBoost(p1, 'brawler');
                    const useCount = p1.boostUseCount['brawler'];
                    const hasDoublePlay = p1.secondaryBoost === 'doubleplay';
                    const maxUses = hasDoublePlay ? 2 : 1;
                    showBoostNotification(`${p1.name} activates BRAWLER! ${useCount}/${maxUses} Rerolling...`, 'brawler', p1);
                    resultMsg.textContent = 'BRAWLER activated! Roll again...';
                    console.log(`${p1.name} used Brawler to nullify ${p2.name}'s win`);
                    renderBracket();
                    return;
                }
                // Player 1 won → check if Player 2 has Brawler
                else if (winner === 1 && hasActiveBoost(p2, 'brawler')) {
                    useBoost(p2, 'brawler');
                    const useCount = p2.boostUseCount['brawler'];
                    const hasDoublePlay = p2.secondaryBoost === 'doubleplay';
                    const maxUses = hasDoublePlay ? 2 : 1;
                    showBoostNotification(`${p2.name} activates BRAWLER! ${useCount}/${maxUses} Rerolling...`, 'brawler', p2);
                    resultMsg.textContent = 'BRAWLER activated! Roll again...';
                    console.log(`${p2.name} used Brawler to nullify ${p1.name}'s win`);
                    renderBracket();
                    return;
                }
            }

            // Check if we're in sudden death
            const totalRounds = match.scores.length;
            const p1Wins = match.scores.filter(s => s.winner === 1).length;
            const p2Wins = match.scores.filter(s => s.winner === 2).length;
            const inSuddenDeath = totalRounds >= match.bestOf && p1Wins === p2Wins;

            // ✅ ALWAYS add the score (including sudden death rolls)
            match.scores.push({ roll1, roll2, winner, result: winner === 0 ? 'tie' : 'win' });

            resultMsg.textContent = message;
            trackRoll(roll1, roll2); // Track the roll for stats

            // Add to roll history
            const rollResult = winner === 1 ? 'p1' : (winner === 2 ? 'p2' : 'tie');
            addRollToHistory(p1, p2, roll1, roll2, rollResult);

            // ✅ NEW: Add to replay history (with boost metadata if applicable)
            const replayData = { 
                roll1, 
                roll2, 
                winner, 
                result: winner === 0 ? 'tie' : 'win'
            };
            addToReplayHistory('roll', replayData);

            // Check for Guardian (win first roll → auto-win second roll)
            if (isFirstRoll && winner === 1 && hasActiveBoost(p1, 'guardian')) {
                useBoost(p1, 'guardian');
                const useCount = p1.boostUseCount['guardian'];
                const hasDoublePlay = p1.secondaryBoost === 'doubleplay';
                const maxUses = hasDoublePlay ? 2 : 1;
                showBoostNotification(`${p1.name} activates GUARDIAN! ${useCount}/${maxUses} Auto-win next round!`, 'guardian', p1);
                setTimeout(() => {
                    const guardianScore = { roll1: 0, roll2: 0, winner: 1, result: 'guardian' };
                    match.scores.push(guardianScore);
                    addToReplayHistory('roll', guardianScore); // ✅ NEW: Add to replay
                    resultMsg.textContent = `${p1.name} auto-wins with GUARDIAN!`;
                    playWinSound();
                    checkMatchWinner();
                }, 2000);
                renderBracket();
                return;
            } else if (isFirstRoll && winner === 2 && hasActiveBoost(p2, 'guardian')) {
                useBoost(p2, 'guardian');
                const useCount = p2.boostUseCount['guardian'];
                const hasDoublePlay = p2.secondaryBoost === 'doubleplay';
                const maxUses = hasDoublePlay ? 2 : 1;
                showBoostNotification(`${p2.name} activates GUARDIAN! ${useCount}/${maxUses} Auto-win next round!`, 'guardian', p2);
                setTimeout(() => {
                    const guardianScore = { roll1: 0, roll2: 0, winner: 2, result: 'guardian' };
                    match.scores.push(guardianScore);
                    addToReplayHistory('roll', guardianScore); // ✅ NEW: Add to replay
                    resultMsg.textContent = `${p2.name} auto-wins with GUARDIAN!`;
                    playWinSound();
                    checkMatchWinner();
                }, 2000);
                renderBracket();
                return;
            }

            // Check win condition
            checkMatchWinner();
        }

        // Check match winner
        function checkMatchWinner() {
            const match = matches[currentMatchIndex];
            const resultMsg = document.getElementById('resultMessage');
            const p1 = match.player1;
            const p2 = match.player2;

            // Count wins
            const p1Wins = match.scores.filter(s => s.winner === 1).length;
            const p2Wins = match.scores.filter(s => s.winner === 2).length;
            const totalRounds = match.scores.length;

            const winsNeeded = Math.floor(match.bestOf / 2) + 1;

            console.log(`Match check: P1=${p1Wins} wins, P2=${p2Wins} wins, Total rounds=${totalRounds}, Wins needed=${winsNeeded}, BestOf=${match.bestOf}`);

            // DURING REGULATION
            if (totalRounds < match.bestOf) {
                if (p1Wins >= winsNeeded) {
                    // ✅ CHECK REVIVE FIRST (before setting winner)
                    if (checkReviveProc(1)) { // Player 2 (index 1) is the loser
                        return; // Revive proc'd, continue match
                    }
                    
                    // ✅ ONLY set winner and show continue button if revive didn't proc
                    match.winner = p1;
                    const winnerElement = findPlayerElement(p1);
                    if (winnerElement) {
                        triggerWinnerEffects(p1, winnerElement);
                    }
                    resultMsg.textContent = `${p1.name} wins the match!`;
                    playMatchCompleteSound();
                    checkForComeback(p1Wins, p2Wins, p1, match.bestOf);
                    // Disable the roll button immediately to prevent double-clicks
                    document.getElementById('rollButton').disabled = true;

                    // Small delay so the user sees the final winning roll/effect before the splash covers it
                    setTimeout(() => {
                        showMatchEndSplash(match.winner);
                    }, 800);
                    return;

                } else if (p2Wins >= winsNeeded) {
                    // ✅ CHECK REVIVE FIRST (before setting winner)
                    if (checkReviveProc(0)) { // Player 1 (index 0) is the loser
                        return; // Revive proc'd, continue match
                    }
                    
                    // ✅ ONLY set winner and show continue button if revive didn't proc
                    match.winner = p2;
                    const winnerElement = findPlayerElement(p2);
                    if (winnerElement) {
                        triggerWinnerEffects(p2, winnerElement);
                    }
                    resultMsg.textContent = `${p2.name} wins the match!`;
                    playMatchCompleteSound();
                    checkForComeback(p1Wins, p2Wins, p2, match.bestOf);
                    // Disable the roll button immediately to prevent double-clicks
                    document.getElementById('rollButton').disabled = true;

                    // Small delay so the user sees the final winning roll/effect before the splash covers it
                    setTimeout(() => {
                        showMatchEndSplash(match.winner);
                    }, 800);
                    return;
                }
            }
            // REGULATION ENDED
            else if (totalRounds === match.bestOf) {
                if (p1Wins > p2Wins) {
                    // ✅ CHECK REVIVE FIRST
                    if (checkReviveProc(1)) {
                        return;
                    }
                    
                    match.winner = p1;
                    const winnerElement = findPlayerElement(p1);
                    if (winnerElement) {
                        triggerWinnerEffects(p1, winnerElement);
                    }
                    resultMsg.textContent = `${p1.name} wins the match!`;
                    checkForComeback(p1Wins, p2Wins, p1, match.bestOf);
                    showMatchEndSplash(match.winner);
                    return;
                } else if (p2Wins > p1Wins) {
                    // ✅ CHECK REVIVE FIRST
                    if (checkReviveProc(0)) {
                        return;
                    }
                    
                    match.winner = p2;
                    const winnerElement = findPlayerElement(p2);
                    if (winnerElement) {
                        triggerWinnerEffects(p2, winnerElement);
                    }
                    resultMsg.textContent = `${p2.name} wins the match!`;
                    checkForComeback(p1Wins, p2Wins, p2, match.bestOf);
                    showMatchEndSplash(match.winner);
                    return;
                } else {
                    resultMsg.textContent = "⚡ SUDDEN DEATH! Next score wins!";
                }
            }
            // SUDDEN DEATH
            else {
                const lastScore = match.scores[match.scores.length - 1];
                if (lastScore.winner !== 0) {
                    const loserIndex = lastScore.winner === 1 ? 1 : 0; // Determine loser
                    
                    // ✅ CHECK REVIVE FIRST
                    if (checkReviveProc(loserIndex)) {
                        return; // Revive proc'd, continue match
                    }
                    
                    // ✅ ONLY set winner and track sudden death if revive didn't proc
                    match.winner = lastScore.winner === 1 ? p1 : p2;
                    
                    const winnerElement = findPlayerElement(match.winner);
                    if (winnerElement) {
                        triggerWinnerEffects(match.winner, winnerElement);
                    }

                    if (!match.suddenDeathTracked) {
                        gameStats.suddenDeathMatches++;
                        match.suddenDeathTracked = true;
                        saveStats();
                    }
                    resultMsg.textContent = `${match.winner.name} wins in SUDDEN DEATH!`;
                    checkForComeback(p1Wins, p2Wins, match.winner, match.bestOf);
                    showMatchEndSplash(match.winner);
                    return;
                } else {
                    resultMsg.textContent = "Tie! Roll again...";
                }
            }

            renderBracket();
            updateMatchInfo();
        }

        // Show continue button and hide roll button
        function showContinueButton() {
            const rollBtn = document.getElementById('rollButton');
            const continueBtn = document.getElementById('continueButton');
            
            rollBtn.style.display = 'none';
            continueBtn.classList.add('show');
            
            renderBracket();
            updateMatchInfo();
        }

        // Hide continue button and show roll button
        function hideContinueButton() {
            const rollBtn = document.getElementById('rollButton');
            const continueBtn = document.getElementById('continueButton');
            
            rollBtn.style.display = 'block';
            continueBtn.classList.remove('show');
        }

        // Advance to next match or round
        function advanceMatch() {
            const match = matches[currentMatchIndex];
            const resultMsg = document.getElementById('resultMessage');
            const loser = match.player1.id === match.winner.id ? match.player2 : match.player1;

            // Check for Revive boost FIRST (loser can revive before winner scavenges)
            if (hasActiveBoost(loser, 'revive')) {
                useBoost(loser, 'revive');
                const useCount = loser.boostUseCount['revive'];
                const hasDoublePlay = loser.secondaryBoost === 'doubleplay';
                const maxUses = hasDoublePlay ? 2 : 1;
                showBoostNotification(`${loser.name} activates REVIVE! ${useCount}/${maxUses} Replaying final round...`, 'revive', loser);

                // Remove last score
                match.scores.pop();
                match.winner = null;

                resultMsg.textContent = 'REVIVE activated! Roll again...';
                renderBracket();
                updateMatchInfo();
                // Restore roll button visibility for next match
                hideContinueButton();
                return;
            }

            // Check for Scavenger boost (winner steals loser's boost)
            // Only runs if Revive didn't activate
            const winner = match.winner;
            if (hasActiveBoost(winner, 'scavenger') && currentRound < 3) {
                // Scavenger only works if there's a next match (not in Finals)
                const loserBoost = loser.primaryBoost;

                // Can't scavenge Thief, Saboteur, Scavenger, or no boost
                if (loserBoost && loserBoost !== 'none' && loserBoost !== 'thief' && loserBoost !== 'saboteur' && loserBoost !== 'scavenger') {
                    // Check if loser's boost has uses left
                    const loserUseCount = loser.boostUseCount[loserBoost] || 0;
                    const loserHasDoublePlay = loser.secondaryBoost === 'doubleplay';
                    const loserMaxUses = loserHasDoublePlay ? 2 : 1;

                    if (loserUseCount < loserMaxUses) {
                        // Loser's boost has uses left - give winner a fresh copy
                        winner.scavengedBoost = loserBoost;
                        winner.boostUseCount[loserBoost] = 0;
                        showBoostNotification(`${winner.name} scavenged ${getBoostDisplayName(loserBoost)} from ${loser.name}!`, 'scavenger', winner);
                        console.log(`Scavenger: ${winner.name} got fresh ${loserBoost} from ${loser.name}`);
                    } else {
                        // Loser's boost is used up - give winner a random active boost
                        const randomBoosts = ['brawler', 'guardian', 'nosdemon', 'revive'];
                        const randomBoost = randomBoosts[Math.floor(Math.random() * randomBoosts.length)];
                        winner.scavengedBoost = randomBoost;
                        winner.boostUseCount[randomBoost] = 0;
                        showBoostNotification(`${winner.name} scavenged parts and created ${getBoostDisplayName(randomBoost)}!`, 'scavenger', winner);
                        console.log(`Scavenger: ${winner.name} got random ${randomBoost} from used ${loserBoost}`);
                    }

                    // Mark Scavenger as used
                    useBoost(winner, 'scavenger');
                } else {
                    console.log(`Scavenger: ${winner.name} couldn't scavenge from ${loser.name} (boost: ${loserBoost})`);
                }
            }

            console.log(`Advancing from Round ${currentRound}, Match ${currentMatchIndex + 1}`);

            // Track match win IMMEDIATELY after match completes
            trackMatchWin(winner); // Track match win for stats

            if (currentMatchIndex < matches.length - 1) {
                // Next match in current round
                currentMatchIndex++;
                clearReplayHistory(); // ✅ NEW: Clear replay history for new match
                resultMsg.textContent = '';
                document.getElementById('die1').textContent = '?';
                document.getElementById('die2').textContent = '?';

                showMatchStartSplash();
            } else {
                // Round complete - reset stolen boosts
                players.forEach(p => delete p.stolenBoost);

                if (currentRound === 1) {
                    currentRound = 2;
                    currentMatchIndex = 0;

                    const winners = matches.map(m => m.winner);

                    // STORE ROUND 1 MATCHES FOR HISTORY
                    window.round1Matches = JSON.parse(JSON.stringify(matches));

                    matches = [
                        { player1: winners[0], player2: winners[1], bestOf: 5, scores: [], winner: null },
                        { player1: winners[2], player2: winners[3], bestOf: 5, scores: [], winner: null }
                    ];

                    // Apply Decryptor Interference to Round 2 if applicable
                    if (tournamentInterference.decryptor && tournamentInterference.decryptor.round === 2) {
                        const idx = tournamentInterference.decryptor.matchIndex;
                        const reduction = tournamentInterference.decryptor.reduction;
                        matches[idx].bestOf -= reduction;
                        matches[idx].decryptorInterference = reduction;
                        console.log(`Applied Decryptor to Round 2 Match ${idx + 1}: Best of ${matches[idx].bestOf}`);
                    }

                    // Apply Cosmic Storm to Round 2 if applicable
                    if (tournamentInterference.cosmicStorm && tournamentInterference.cosmicStorm.round === 2) {
                        const idx = tournamentInterference.cosmicStorm.matchIndex;
                        matches[idx].cosmicStorm = true;
                        console.log(`Applied Cosmic Storm to Round 2 Match ${idx + 1}`);
                    }

                    // Hide the game area during transition
                    document.getElementById('gameArea').style.opacity = '0';
                    
                    // Keep splash visible during transition
                    const splash = document.getElementById('matchSplashScreen');
                    const title = document.getElementById('splashTitle');
                    const matchInfo = document.getElementById('splashMatchInfo');
                    
                    title.textContent = 'ROUND 2 BEGINS!';
                    matchInfo.textContent = 'Get ready for the semifinals...';
                    
                    // Show splash immediately
                    splash.classList.add('show');

                    setTimeout(() => {
                    // Restore game area visibility
                    document.getElementById('gameArea').style.opacity = '1';
                    // Show the first match of Round 2
                    showMatchStartSplash();
                    }, 2000);

                } else if (currentRound === 2) {
                    currentRound = 3;
                    currentMatchIndex = 0;

                    const winners = matches.map(m => m.winner);

                    // STORE ROUND 2 MATCHES FOR HISTORY
                    window.round2Matches = JSON.parse(JSON.stringify(matches));

                    matches = [
                    { player1: winners[0], player2: winners[1], bestOf: 7, scores: [], winner: null }
                    ];

                    // Check for Gang Takeover
                    const isGangTakeover = winners[0].gang === winners[1].gang;

                    if (isGangTakeover) {
                    // Mark match as gang takeover
                    matches[0].gangTakeover = true;
                    matches[0].gangColor = winners[0].color;
                    
                    // Play takeover sound
                    playGangTakeoverSound();
                    
                    // Show enhanced notification
                    const gangName = winners[0].gang.toUpperCase();
                    showEnhancedNotification(`🔥 GANG TAKEOVER! ${gangName} CONTROLS THE FINALS! 🔥`, 5000);
                    
                    resultMsg.textContent = `🔥 GANG TAKEOVER! ${gangName} 🔥`;
                    
                    console.log(`Gang Takeover: ${gangName}`);
                    } else {
                    resultMsg.textContent = '🏆 FINALS! 🏆';
                    }

                    // Hide the game area during transition
                    document.getElementById('gameArea').style.opacity = '0';
                    
                    // Keep splash visible during transition
                    const splash = document.getElementById('matchSplashScreen');
                    const title = document.getElementById('splashTitle');
                    const matchInfo = document.getElementById('splashMatchInfo');
                    
                    if (isGangTakeover) {
                        const gangName = winners[0].gang.toUpperCase();
                        title.textContent = `🔥 ${gangName} TAKEOVER! 🔥`;
                        matchInfo.textContent = 'The finals will be an all-gang showdown!';
                    } else {
                        title.textContent = 'ROUND 3: FINALS!';
                        matchInfo.textContent = 'The championship match is about to begin...';
                    }
                    
                    // Show splash immediately
                    splash.classList.add('show');

                    setTimeout(() => {
                    // Restore game area visibility
                    document.getElementById('gameArea').style.opacity = '1';
                    // Show the finals match
                    showMatchStartSplash();
                    }, 2000);

                } else if (currentRound === 3) {
                    // Finals complete - show winner
                    showWinner(match.winner);
                    }
                }
        }

        // Show winner screen (V2 ENHANCED WITH SOUND)
        function showWinner(winner) {
            document.getElementById('winnerName').textContent = winner.name;
            document.getElementById('winnerName').style.color = winner.color;
            
            // Update NFT and Gang info
            document.getElementById('winnerNFTImg').src = getPlayerNFTUrl(winner.riderId);
            document.getElementById('winnerNFTContainer').style.borderColor = winner.color;
            const winnerGangEl = document.getElementById('winnerGang');
            winnerGangEl.innerHTML = `
                <img src="${GANG_ICONS[winner.gang]}" alt="${winner.gang}" style="width: 28px; height: 28px; vertical-align: middle; margin-right: 10px;">
                ${winner.gang || ''}
            `;
            document.getElementById('winnerGang').style.color = winner.color;
            document.getElementById('winnerRiderId').textContent = `#${winner.riderId}`;

            const screen = document.getElementById('winnerScreen');
            screen.classList.add('show');
            
           // Confetti - burst from NFT container
            const nftContainer = document.getElementById('winnerNFTContainer');
            for (let i = 0; i < 20; i++) {
                setTimeout(() => createConfetti(nftContainer, winner.color), i * 35);
            }
            
            gameStats.tournamentWins++;
            saveStats();
        }

        // Restart tournament
        document.getElementById('restartButton').addEventListener('click', function() {
            document.getElementById('winnerScreen').classList.remove('show');
            document.getElementById('gameArea').classList.remove('show');
            document.getElementById('boostSetupScreen').classList.add('show');
            document.getElementById('die1').textContent = '?';
            document.getElementById('die2').textContent = '?';
            document.getElementById('resultMessage').textContent = '';
            tournamentInterference = null;
            initGame();
        });

        // ====
        // CUSTOM PLAYERS POPUP
        // ====

        function openCustomPlayersPopup() {
            const popup = document.getElementById('customPlayersPopup');
            const inputsContainer = document.getElementById('customPlayersInputs');
            
            // Generate input fields for all 8 players
            let html = '';
            players.forEach((player, index) => {
                const gangName = player.gang || 'Unknown';
                const gangColor = player.color || '#ffffff';
                
                html += `<div class="custom-player-input" style="border-left-color: ${gangColor};">`;
                html += `<div class="custom-player-icon" style="border-color: ${gangColor};">
                    <img src="${getPlayerNFTUrl(player.riderId)}" alt="${player.name}">
                </div>`;
                html += `<div class="custom-player-label">P${index + 1}</div>`;
                html += `<input type="text" id="customName${index}" placeholder="Player Name" value="${player.name}" maxlength="20">`;
                html += `<input type="number" id="customId${index}" placeholder="ID (1-1000)" value="${player.riderId}" min="1" max="1000" onchange="updateGangBadge(${index})">`;
                html += `<div class="custom-player-gang-badge" id="gangBadge${index}" style="border-color: ${gangColor}; color: ${gangColor};">
                    ${getGangIconHTML(gangName, '20px')}
                    ${gangName}
                </div>`;
                html += `</div>`;
                html += `</div>`;
            });
            
            inputsContainer.innerHTML = html;
            popup.classList.add('show');
        }

        function updateGangBadge(playerIndex) {
            const riderIdInput = document.getElementById(`customId${playerIndex}`);
            const gangBadge = document.getElementById(`gangBadge${playerIndex}`);
            const playerRow = gangBadge.closest('.custom-player-input');
            
            const riderId = parseInt(riderIdInput.value);
            
            if (riderId >= 1 && riderId <= 1000 && METADATA[riderId]) {
                const gangName = METADATA[riderId].gang;
                const gangColor = GANG_COLORS[gangName] || '#ffffff';
                
                gangBadge.innerHTML = getGangIconHTML(gangName, '20px') + gangName;
                gangBadge.style.borderColor = gangColor;
                gangBadge.style.color = gangColor;
                playerRow.style.borderLeftColor = gangColor;
            } else {
                gangBadge.textContent = 'Unknown';
                gangBadge.style.borderColor = '#666';
                gangBadge.style.color = '#666';
                playerRow.style.borderLeftColor = 'transparent';
            }
        }

        function closeCustomPlayersPopup() {
            const popup = document.getElementById('customPlayersPopup');
            const errorMsg = document.getElementById('customPlayersError');
            popup.classList.remove('show');
            errorMsg.classList.remove('show');
        }

        function applyCustomPlayers() {
            const errorMsg = document.getElementById('customPlayersError');
            errorMsg.classList.remove('show');
            
            // Collect and validate inputs
            const customData = [];
            let hasError = false;
            
            for (let i = 0; i < 8; i++) {
                const nameInput = document.getElementById(`customName${i}`);
                const idInput = document.getElementById(`customId${i}`);
                
                const name = nameInput.value.trim();
                const id = parseInt(idInput.value);
                
                // Reset error styling
                nameInput.classList.remove('error');
                idInput.classList.remove('error');
                
                // Validate name
                if (!name || name.length === 0) {
                    nameInput.classList.add('error');
                    hasError = true;
                }
                
                // Validate ID (1-1000)
                if (isNaN(id) || id < 1 || id > 1000) {
                    idInput.classList.add('error');
                    hasError = true;
                }
                
                customData.push({ name, id: String(id) });
            }
            
            // Show error if validation failed
            if (hasError) {
                errorMsg.textContent = 'Please fix the highlighted fields. Names cannot be empty, and IDs must be between 1-1000.';
                errorMsg.classList.add('show');
                return;
            }
            
            // Apply custom data to players
            players.forEach((player, index) => {
                player.name = customData[index].name;
                player.riderId = customData[index].id;
                player.initials = customData[index].name.substring(0, 2).toUpperCase();
            });
            
            // Re-render boost setup with new names/IDs
            renderBoostSetup();
            
            // Close popup
            closeCustomPlayersPopup();
            
            console.log('Custom players applied:', players.map(p => ({ name: p.name, id: p.riderId })));
        }

        // Start game on load
        initGame();

        // Resume audio context on first user interaction
        document.addEventListener('click', function resumeAudio() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('Audio context resumed');
                });
            }
        }, { once: true });
    
        // ============================================
        // TEST MODE FUNCTIONS
        // ============================================

        function toggleRollHistory() {
            const panel = document.getElementById('rollHistoryPanel');
            const btn = document.getElementById('rollHistoryToggle');

            if (panel) {
                panel.classList.toggle('active');
                if (btn) {
                    if (panel.classList.contains('active')) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            }
        }

        function toggleTestMode() {
            const panel = document.getElementById('testModePanel');
            panel.classList.toggle('active');
        }

        // Enhanced keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in inputs
            if (document.activeElement.tagName === 'INPUT' || 
                document.activeElement.tagName === 'SELECT' ||
                document.activeElement.tagName === 'TEXTAREA') {
                return;
            }
            
            const key = e.key.toLowerCase();
            
            switch(key) {
                case 't':
                    toggleTestMode();
                    break;
                    
                case 'h':
                    toggleRollHistory();
                    break;
                    
                case ' ': // Space bar
                    e.preventDefault(); // Prevent page scroll
                    const rollBtn = document.getElementById('rollButton');
                    if (rollBtn && !rollBtn.disabled) {
                        rollBtn.click();
                    }
                    break;
                    
                case 'u':
                    const undoBtn = document.getElementById('undoRollButton');
                    if (undoBtn) undoBtn.click();
                    break;
                    
                case 'p':
                    const resetBtn = document.getElementById('resetMatchButton');
                    if (resetBtn) resetBtn.click();
                    break;

                case 'o':
                    const resetRoundBtn = document.getElementById('resetRoundButton');
                    if (resetRoundBtn) resetRoundBtn.click();
                    break;
                    
                case 'b':
                    // Toggle bracket view
                    if (bracketViewMode === 'current') {
                        switchBracketView('full');
                    } else {
                        switchBracketView('current');
                    }
                    break;
                    
                case 'm':
                    toggleSound();
                    break;
                    
                case 's':
                    toggleStats();
                    break;

                case '?':
                    toggleKeyboardHelp();
                    break;
                    
                case 'escape':
                    // Close help overlay if open
                    const helpOverlay = document.getElementById('keyboardHelpOverlay');
                    if (helpOverlay && helpOverlay.classList.contains('show')) {
                        toggleKeyboardHelp();
                    }
                    break;
            }
        });

        // Toggle keyboard help overlay
        function toggleKeyboardHelp() {
            const overlay = document.getElementById('keyboardHelpOverlay');
            overlay.classList.toggle('show');
        }

        function applyBoostAssignment() {
            const playerIdx = parseInt(document.getElementById('testPlayerSelect').value);
            const primary = document.getElementById('testPrimaryBoost').value;
            const secondary = document.getElementById('testSecondaryBoost').value;
            const restriction = document.getElementById('testRoundRestriction').value;

            players[playerIdx].primaryBoost = primary;
            players[playerIdx].secondaryBoost = secondary;
            players[playerIdx].roundRestriction = restriction;
            players[playerIdx].boostUsageCount = {};

            console.log(`TEST MODE: Applied boosts to ${players[playerIdx].name}`);
            console.log(`  Primary: ${primary}, Secondary: ${secondary}, Restriction: ${restriction}`);

            renderBoostSetup();
            alert(`Boosts applied to ${players[playerIdx].name}!`);
        }

        // Add roll to history
        function addRollToHistory(player1, player2, roll1, roll2, result) {
            const historyItem = {
                round: currentRound,
                match: currentMatchIndex + 1,
                player1: { name: player1.name, riderId: player1.riderId, color: player1.color },
                player2: { name: player2.name, riderId: player2.riderId, color: player2.color },
                roll1: roll1,
                roll2: roll2,
                result: result, // 'p1', 'p2', or 'tie'
                timestamp: Date.now()
            };

            rollHistory.push(historyItem); // ✅ CHANGED: Add to end instead of beginning
            if (rollHistory.length > 10) {
                rollHistory.shift(); // ✅ CHANGED: Remove from beginning to keep last 10
            }

            renderRollHistory();
        }

        // Render roll history panel
        function renderRollHistory() {
            const list = document.getElementById('rollHistoryList');

            if (rollHistory.length === 0) {
                list.innerHTML = '<div style="text-align: center; color: #95a5a6; padding: 20px;">No rolls yet</div>';
                return;
            }

            let html = '';
            rollHistory.forEach((item, index) => {
                const isTie = item.result === 'tie';
                const winner = item.result === 'p1' ? item.player1 : (item.result === 'p2' ? item.player2 : null);

                html += `<div class="roll-history-item ${isTie ? 'tie' : ''}">`;
                html += `<div class="roll-history-header">`;
                html += `<span>R${item.round} M${item.match}</span>`;
                html += `<span>${isTie ? 'TIE' : '✓'}</span>`;
                html += `</div>`;
                html += `<div class="roll-history-players">`;

                // Player 1
                const p1Winner = item.result === 'p1';
                html += `<div class="roll-history-player ${p1Winner ? 'winner' : ''}">`;
                html += `<div class="roll-history-die">${item.roll1}</div>`;
                html += `<div class="roll-history-name" style="color: ${item.player1.color}">${item.player1.name.replace('Player ', 'P')}</div>`;
                html += `</div>`;

                html += `<div class="roll-history-vs">vs</div>`;

                // Player 2
                const p2Winner = item.result === 'p2';
                html += `<div class="roll-history-player ${p2Winner ? 'winner' : ''}">`;
                html += `<div class="roll-history-name" style="color: ${item.player2.color}">${item.player2.name.replace('Player ', 'P')}</div>`;
                html += `<div class="roll-history-die">${item.roll2}</div>`;
                html += `</div>`;

                html += `</div>`;
                html += `</div>`;
            });

            list.innerHTML = html;
        }


        function skipToRound(targetRound) {
            if (currentRound >= targetRound) {
                alert(`Already at or past Round ${targetRound}!`);
                return;
            }

            // Helper function to safely show tournament screen
            function showTournamentScreen() {
                const boostSetup = document.getElementById('boostSetup');
                const tournament = document.getElementById('tournament');
                if (boostSetup) boostSetup.style.display = 'none';
                if (tournament) tournament.style.display = 'block';
            }

            if (targetRound === 2) {
                // Skip to Round 2 - need to finish Round 1

                // If tournament hasn't started, start it first
                if (currentRound === 0) {
                    startTournament();
                    // Wait for tournament to initialize
                    setTimeout(() => {
                        skipToRound(2); // Retry after tournament starts
                    }, 100);
                    return;
                }

                if (currentRound === 1) {
                    // Auto-complete all Round 1 matches (Player 1 always wins for testing)
                    for (let i = 0; i < 4; i++) {
                        if (!matches[i].winner) {
                            matches[i].winner = matches[i].player1;
                            matches[i].scores = [{winner: 1, p1: 6, p2: 1}, {winner: 1, p1: 6, p2: 1}];
                        }
                    }

                    // Advance to Round 2
                    currentRound = 2;
                    currentMatchIndex = 0;
                    const winners = matches.map(m => m.winner);

                    matches = [
                        { player1: winners[0], player2: winners[1], bestOf: 5, scores: [], winner: null },
                        { player1: winners[2], player2: winners[3], bestOf: 5, scores: [], winner: null }
                    ];

                    showTournamentScreen();
                    renderBracket();
                    updateMatchInfo();

                    console.log('TEST MODE: Skipped to Round 2');
                    alert('Skipped to Round 2!');
                }
            } else if (targetRound === 3) {
                // Skip to Finals

                // If tournament hasn't started, start it first
                if (currentRound === 0) {
                    startTournament();
                    // Wait for tournament to initialize
                    setTimeout(() => {
                        skipToRound(3); // Retry after tournament starts
                    }, 100);
                    return;
                }

                // Auto-complete Round 1 if needed
                if (currentRound === 1) {
                    // Auto-complete Round 1 (Player 1 always wins for testing) and simulate boost usage
                    for (let i = 0; i < 4; i++) {
                        if (!matches[i].winner) {
                            matches[i].winner = matches[i].player1;
                            matches[i].scores = [{winner: 1, p1: 6, p2: 1}, {winner: 1, p1: 6, p2: 1}];

                            // Simulate boost usage for Round 1 boosts
                            const p1 = matches[i].player1;
                            const p2 = matches[i].player2;
                            if (p1.roundRestriction === 'round1' && p1.primaryBoost !== 'none') {
                                useBoost(p1, p1.primaryBoost);
                            }
                            if (p2.roundRestriction === 'round1' && p2.primaryBoost !== 'none') {
                                useBoost(p2, p2.primaryBoost);
                            }
                        }
                    }

                    // Create Round 2 matches
                    currentRound = 2;
                    const r1Winners = matches.map(m => m.winner);
                    matches = [
                        { player1: r1Winners[0], player2: r1Winners[1], bestOf: 5, scores: [], winner: null },
                        { player1: r1Winners[2], player2: r1Winners[3], bestOf: 5, scores: [], winner: null }
                    ];
                }

                // Auto-complete Round 2 (Player 1 always wins for testing) and simulate boost usage
                if (currentRound === 2) {
                    for (let i = 0; i < 2; i++) {
                        if (!matches[i].winner) {
                            matches[i].winner = matches[i].player1;
                            matches[i].scores = [{winner: 1, p1: 6, p2: 1}, {winner: 1, p1: 6, p2: 1}, {winner: 1, p1: 6, p2: 1}];

                            // Simulate boost usage for Round 2 boosts
                            const p1 = matches[i].player1;
                            const p2 = matches[i].player2;
                            if ((p1.roundRestriction === 'round1' || p1.roundRestriction === 'round2') && p1.primaryBoost !== 'none') {
                                useBoost(p1, p1.primaryBoost);
                            }
                            if ((p2.roundRestriction === 'round1' || p2.roundRestriction === 'round2') && p2.primaryBoost !== 'none') {
                                useBoost(p2, p2.primaryBoost);
                            }
                        }
                    }

                    // Advance to Finals
                    currentRound = 3;
                    currentMatchIndex = 0;
                    const r2Winners = matches.map(m => m.winner);

                    matches = [
                        { player1: r2Winners[0], player2: r2Winners[1], bestOf: 7, scores: [], winner: null }
                    ];

                    showTournamentScreen();
                    processMatchStartBoosts();  // Process boosts for Finals match
                    renderBracket();
                    updateMatchInfo();

                    console.log('TEST MODE: Skipped to Finals');
                    alert('Skipped to Finals!');
                }
            }
        }

        function forceDecryptor() {
            const match = matches[currentMatchIndex];
            if (!match) {
                alert('No active match!');
                return;
            }

            const reduction = currentRound === 1 ? 1 : 2;
            match.bestOf -= reduction;
            match.decryptorInterference = reduction;

            console.log(`TEST MODE: Forced Decryptor on current match (-${reduction} rounds)`);
            renderBracket();
            updateMatchInfo();
            alert(`Decryptor applied! Best of ${match.bestOf + reduction} → Best of ${match.bestOf}`);
        }

        function forceCosmicStorm() {
            const match = matches[currentMatchIndex];
            if (!match) {
                alert('No active match!');
                return;
            }

            match.cosmicStorm = true;

            console.log('TEST MODE: Forced Cosmic Storm on current match');
            renderBracket();
            updateMatchInfo();
            alert('Cosmic Storm applied! All boosts disabled for this match.');
        }

        function clearInterference() {
            const match = matches[currentMatchIndex];
            if (!match) {
                alert('No active match!');
                return;
            }

            if (match.decryptorInterference) {
                match.bestOf += match.decryptorInterference;
                delete match.decryptorInterference;
            }
            if (match.cosmicStorm) {
                delete match.cosmicStorm;
            }

            console.log('TEST MODE: Cleared all interference from current match');
            renderBracket();
            updateMatchInfo();
            alert('All interference cleared!');
        }

        function setMatchScore() {
        const scoreInput = document.getElementById('testScore').value;
        const match = matches[currentMatchIndex];

        if (!match) {
            alert('No active match!');
            return;
        }

        // Support formats: "2-1" or "2-1-3" (P1wins-P2wins-Ties)
        const parts = scoreInput.split('-');
        if (parts.length < 2 || parts.length > 3) {
            alert('Invalid format! Use: P1wins-P2wins or P1wins-P2wins-Ties (e.g., 2-1 or 2-2-1)');
            return;
        }

        const p1Wins = parseInt(parts[0]);
        const p2Wins = parseInt(parts[1]);
        const ties = parts.length === 3 ? parseInt(parts[2]) : 0;

        if (isNaN(p1Wins) || isNaN(p2Wins) || isNaN(ties)) {
            alert('Invalid numbers!');
            return;
        }

        // Create fake scores (interleave for realism)
        match.scores = [];
        const totalRounds = p1Wins + p2Wins + ties;
        let p1Count = 0, p2Count = 0, tieCount = 0;

        for (let i = 0; i < totalRounds; i++) {
            // Distribute evenly
            if (p1Count < p1Wins && (i % 3 === 0 || p2Count >= p2Wins)) {
                match.scores.push({
                    roll1: 6,  // ✅ ADD THIS
                    roll2: 1,  // ✅ ADD THIS
                    winner: 1,
                    result: 'win'  // ✅ ADD THIS
                });
                p1Count++;
            } else if (p2Count < p2Wins && (i % 3 === 1 || p1Count >= p1Wins)) {
                match.scores.push({
                    roll1: 1,  // ✅ ADD THIS
                    roll2: 6,  // ✅ ADD THIS
                    winner: 2,
                    result: 'win'  // ✅ ADD THIS
                });
                p2Count++;
            } else if (tieCount < ties) {
                match.scores.push({
                    roll1: 3,  // ✅ ADD THIS
                    roll2: 3,  // ✅ ADD THIS
                    winner: 0,
                    result: 'tie'  // ✅ ADD THIS
                });
                tieCount++;
            }
        }

        const scoreStr = ties > 0 ? `${p1Wins}-${p2Wins} (${ties} ties)` : `${p1Wins}-${p2Wins}`;
        console.log(`TEST MODE: Set match score to ${scoreStr}`);
        renderBracket();
        updateMatchInfo();
        alert(`Score set to ${scoreStr}!`);
    }

        function resetCurrentMatch() {
            const match = matches[currentMatchIndex];
            if (!match) {
                alert('No active match!');
                return;
            }

            match.scores = [];
            match.winner = null;
            document.getElementById('die1').textContent = '?';
            document.getElementById('die2').textContent = '?';
            document.getElementById('resultMessage').textContent = '';

            console.log('TEST MODE: Reset current match');
            renderBracket();
            updateMatchInfo();
            alert('Current match reset!');
        }

        function resetTournament() {
            if (confirm('Reset entire tournament? This will clear all progress!')) {
                location.reload();
            }
        }

        // Export rounds data as JSON
        function exportRounds() {
            const exportData = {
                timestamp: new Date().toISOString(),
                currentRound: currentRound,
                currentMatchIndex: currentMatchIndex,
                players: players.map(p => ({
                    id: p.id,
                    name: p.name,
                    riderId: p.riderId,
                    gang: p.gang,
                    color: p.color,
                    primaryBoost: p.primaryBoost,
                    secondaryBoost: p.secondaryBoost,
                    roundRestriction: p.roundRestriction,
                    boostUseCount: p.boostUseCount,
                    usedBoosts: p.usedBoosts
                })),
                round1Matches: window.round1Matches || [],
                round2Matches: window.round2Matches || [],
                currentMatches: matches,
                matchHistory: replayFullHistory,
                interference: tournamentInterference,
                stats: gameStats
            };
            
            // Create downloadable file
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            // Create temporary download link
            const link = document.createElement('a');
            link.href = url;
            link.download = `meta8_showdown_export_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            console.log('Exported tournament data:', exportData);
            alert('Tournament data exported successfully!');
        }

        // Export current match only
        function exportMatch() {
            const match = matches[currentMatchIndex];
            if (!match) {
                alert('No active match to export!');
                return;
            }
            
            const exportData = {
                timestamp: new Date().toISOString(),
                round: currentRound,
                matchIndex: currentMatchIndex,
                match: {
                    player1: {
                        id: match.player1.id,
                        name: match.player1.name,
                        riderId: match.player1.riderId,
                        gang: match.player1.gang,
                        color: match.player1.color
                    },
                    player2: {
                        id: match.player2.id,
                        name: match.player2.name,
                        riderId: match.player2.riderId,
                        gang: match.player2.gang,
                        color: match.player2.color
                    },
                    bestOf: match.bestOf,
                    scores: match.scores,
                    winner: match.winner ? {
                        id: match.winner.id,
                        name: match.winner.name,
                        riderId: match.winner.riderId
                    } : null,
                    cosmicStorm: match.cosmicStorm || false,
                    decryptorInterference: match.decryptorInterference || null
                },
                matchHistory: replayFullHistory
            };
            
            // Create downloadable file
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `meta8_match_export_R${currentRound}M${currentMatchIndex + 1}_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            console.log('Exported match data:', exportData);
            alert('Match data exported successfully!');
        }

        // Rename existing exportRounds to exportTournament
        function exportTournament() {
            const exportData = {
                timestamp: new Date().toISOString(),
                currentRound: currentRound,
                currentMatchIndex: currentMatchIndex,
                players: players.map(p => ({
                    id: p.id,
                    name: p.name,
                    riderId: p.riderId,
                    gang: p.gang,
                    color: p.color,
                    primaryBoost: p.primaryBoost,
                    secondaryBoost: p.secondaryBoost,
                    roundRestriction: p.roundRestriction,
                    boostUseCount: p.boostUseCount,
                    usedBoosts: p.usedBoosts
                })),
                round1Matches: window.round1Matches || [],
                round2Matches: window.round2Matches || [],
                currentMatches: matches,
                matchHistory: replayFullHistory,
                interference: tournamentInterference,
                stats: gameStats
            };
            
            // Create downloadable file
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `meta8_tournament_export_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            console.log('Exported tournament data:', exportData);
            alert('Tournament data exported successfully!');
        }

        // ====
        // BRACKET VISUALIZATION SYSTEM
        // ====

        let bracketViewMode = 'current'; // 'current' or 'full'

        function switchBracketView(mode) {
            bracketViewMode = mode;
            
            const currentBtn = document.getElementById('currentMatchBtn');
            const fullBtn = document.getElementById('fullBracketBtn');
            const currentView = document.getElementById('currentMatchView');
            const fullView = document.getElementById('fullBracketView');
            
            if (mode === 'current') {
                currentBtn.classList.add('active');
                fullBtn.classList.remove('active');
                currentView.style.display = 'block';
                fullView.classList.remove('show');
            } else {
                currentBtn.classList.remove('active');
                fullBtn.classList.add('active');
                currentView.style.display = 'none';
                fullView.classList.add('show');
            }
            
            renderBracket();
        }

        function renderFullBracket() {
            const container = document.getElementById('fullBracketView');
            
            // Get all rounds data
            const round1Matches = getAllRound1Matches();
            const round2Matches = getAllRound2Matches();
            const round3Match = getAllRound3Match();
            
            let html = '<div class="bracket-grid">';
            
            // Round 1
            html += '<div class="bracket-round">';
            html += '<div class="bracket-round-title">Round 1</div>';
            round1Matches.forEach((match, idx) => {
                html += renderBracketMatchCard(match, 1, idx);
            });
            html += '</div>';
            
            // Round 2
            html += '<div class="bracket-round">';
            html += '<div class="bracket-round-title">Round 2 (Semifinals)</div>';
            round2Matches.forEach((match, idx) => {
                html += renderBracketMatchCard(match, 2, idx);
            });
            html += '</div>';
            
            // Round 3 (Finals)
            html += '<div class="bracket-round">';
            html += '<div class="bracket-round-title">Round 3 (Finals)</div>';
            html += renderBracketMatchCard(round3Match, 3, 0);
            html += '</div>';
            
            html += '</div>';
            
            container.innerHTML = html;
        }

        function getAllRound1Matches() {
            // Return stored Round 1 matches if available
            if (window.round1Matches) {
                return window.round1Matches;
            }

            // Return Round 1 matches (either from current matches or reconstruct from players)
            if (currentRound === 1) {
                return matches;
            } else {
                // Fallback: empty matches //OLD: Reconstruct Round 1 from initial players
                return [
                    { player1: players[0], player2: players[1], bestOf: 3, scores: [], winner: players[0], completed: true },
                    { player1: players[2], player2: players[3], bestOf: 3, scores: [], winner: players[2], completed: true },
                    { player1: players[4], player2: players[5], bestOf: 3, scores: [], winner: players[4], completed: true },
                    { player1: players[6], player2: players[7], bestOf: 3, scores: [], winner: players[6], completed: true }
                ];
            }
        }

        function getAllRound2Matches() {
            // Return stored Round 2 matches if available
            if (window.round2Matches) {
                return window.round2Matches;
            }

            if (currentRound === 1) {
                // Round 2 not started yet - show pending
                return [
                    { player1: null, player2: null, bestOf: 5, scores: [], winner: null, pending: true },
                    { player1: null, player2: null, bestOf: 5, scores: [], winner: null, pending: true }
                ];
            } else if (currentRound === 2) {
                return matches;
            } else {
                // Round 3 - reconstruct Round 2
                // This is tricky - we'd need to store Round 2 winners
                // For now, show as completed with current finalists
                return [
                    { player1: matches[0].player1, player2: null, bestOf: 5, scores: [], winner: matches[0].player1, completed: true },
                    { player1: matches[0].player2, player2: null, bestOf: 5, scores: [], winner: matches[0].player2, completed: true }
                ];
            }
        }

        function getAllRound3Match() {
            if (currentRound < 3) {
                return { player1: null, player2: null, bestOf: 7, scores: [], winner: null, pending: true };
            } else {
                return matches[0];
            }
        }

        function renderBracketMatchCard(match, round, matchIndex) {
            const isActive = currentRound === round && currentMatchIndex === matchIndex;
            const isCompleted = match.winner !== null && match.winner !== undefined;
            const isPending = match.pending || (!match.player1 && !match.player2);
            
            let classes = ['bracket-match-card'];
            if (isActive) classes.push('active');
            else if (isCompleted) classes.push('completed');
            else if (isPending) classes.push('pending');
            
            let html = `<div class="${classes.join(' ')}">`;
            
            // Match title
            html += `<div style="text-align: center; font-size: 0.9em; color: #aaa; margin-bottom: 10px;">`;
            html += `Match ${matchIndex + 1} - Best of ${match.bestOf}`;
            html += `</div>`;
            
            // Player 1
            if (match.player1) {
                const p1Wins = match.scores ? match.scores.filter(s => s.winner === 1).length : 0;
                const isWinner = match.winner && match.winner.id === match.player1.id;
                const isLoser = match.winner && match.winner.id !== match.player1.id;
                
                html += `<div class="bracket-player-row ${isWinner ? 'winner' : ''} ${isLoser ? 'loser' : ''}">`;
                html += `
                    <div class="bracket-avatar-small" style="border-color: ${match.player1.color}">
                        <img src="${getPlayerNFTUrl(match.player1.riderId)}" alt="${match.player1.name}">
                    </div>
                `;
                html += `<div class="bracket-player-info">`;
                html += `<div class="bracket-player-name">${getGangIconHTML(match.player1.gang, '18px')} ${match.player1.name}</div>`;
                html += `<div class="bracket-player-score">#${match.player1.riderId}</div>`;
                html += `</div>`;
                if (isCompleted) {
                    html += `<div class="bracket-match-score">${p1Wins}</div>`;
                }
                html += `</div>`;
            } else {
                html += `<div class="bracket-player-row pending">`;
                html += `<div class="bracket-player-info">`;
                html += `<div class="bracket-player-name">TBD</div>`;
                html += `</div>`;
                html += `</div>`;
            }
            
            // Player 2
            if (match.player2) {
                const p2Wins = match.scores ? match.scores.filter(s => s.winner === 2).length : 0;
                const isWinner = match.winner && match.winner.id === match.player2.id;
                const isLoser = match.winner && match.winner.id !== match.player2.id;
                
                html += `<div class="bracket-player-row ${isWinner ? 'winner' : ''} ${isLoser ? 'loser' : ''}">`;
                html += `
                    <div class="bracket-avatar-small" style="border-color: ${match.player2.color}">
                        <img src="${getPlayerNFTUrl(match.player2.riderId)}" alt="${match.player2.name}">
                    </div>
                `;
                html += `<div class="bracket-player-info">`;
                html += `<div class="bracket-player-name">${getGangIconHTML(match.player2.gang, '18px')} ${match.player2.name}</div>`;
                html += `<div class="bracket-player-score">#${match.player2.riderId}</div>`;
                html += `</div>`;
                if (isCompleted) {
                    html += `<div class="bracket-match-score">${p2Wins}</div>`;
                }
                html += `</div>`;
            } else {
                html += `<div class="bracket-player-row pending">`;
                html += `<div class="bracket-player-info">`;
                html += `<div class="bracket-player-name">TBD</div>`;
                html += `</div>`;
                html += `</div>`;
            }
            
            // Connector line (except for finals)
            if (round < 3) {
                html += `<div class="bracket-connector"></div>`;
            }
            
            html += `</div>`;
            return html;
        }

        // ====
        // STATS TRACKING SYSTEM
        // ====

        let gameStats = {
            totalMatches: 0,
            totalRolls: 0,
            comebacks: 0,  // Changed from highestRoll
            tournamentWins: 0,
            suddenDeathMatches: 0,  // NEW
            totalTies: 0,           // NEW
            playerWins: {}, // { "Player 1": 5, "Player 2": 3, ... }
            currentStreak: 0,
            streakPlayer: null
        };

        // Load stats from localStorage
        function loadStats() {
            const saved = localStorage.getItem('meta8Stats');
            if (saved) {
                const loadedStats = JSON.parse(saved);
                
                // Migration: Add new stats if they don't exist
                if (loadedStats.suddenDeathMatches === undefined) {
                    loadedStats.suddenDeathMatches = 0;
                }
                if (loadedStats.totalTies === undefined) {
                    loadedStats.totalTies = 0;
                }
                // Migration: Remove old highestRoll, add comebacks
                if (loadedStats.comebacks === undefined) {
                    loadedStats.comebacks = 0;
                }
                delete loadedStats.highestRoll;  // Clean up old stat
                
                gameStats = loadedStats;
                console.log('Stats loaded from localStorage (with migration)');
            }
        }

        // Save stats to localStorage
        function saveStats() {
            try {
                localStorage.setItem('meta8ShowdownStats', JSON.stringify(gameStats));
                console.log('Stats saved to localStorage');
            } catch (e) {
                console.error('Failed to save stats:', e);
            }
        }

        // Track a roll
        function trackRoll(roll1, roll2) {
            gameStats.totalRolls++;
            
            // Track highest roll
            const maxRoll = Math.max(roll1, roll2);
            if (maxRoll > gameStats.highestRoll) {
                gameStats.highestRoll = maxRoll;
            }
            
            saveStats();
        }

        // Track a match win
        function trackMatchWin(winner) {
            gameStats.totalMatches++;
            
            // Track player wins
            if (!gameStats.playerWins[winner.name]) {
                gameStats.playerWins[winner.name] = 0;
            }
            gameStats.playerWins[winner.name]++;
            
            saveStats();
        }

        // Track a tournament win
        function trackTournamentWin(winner) {
            gameStats.tournamentWins++;
            
            // Update streak
            if (gameStats.streakPlayer === winner.name) {
                gameStats.currentStreak++;
            } else {
                gameStats.currentStreak = 1;
                gameStats.streakPlayer = winner.name;
            }
            
            saveStats();
        }

        // Toggle stats panel
        function toggleStats() {
            const panel = document.getElementById('statsPanel');
            const btn = document.getElementById('statsToggle');
            
            if (panel.classList.contains('active')) {
                panel.classList.remove('active');
                btn.classList.remove('active');
            } else {
                panel.classList.add('active');
                btn.classList.add('active');
                renderStats();
            }
        }

        function checkForComeback(p1Wins, p2Wins, winner, bestOf) {
            const winsNeeded = Math.ceil(bestOf / 2);
            const loserWins = (winner === 'p1') ? p2Wins : p1Wins;
            
            // Comeback = won after being down by (winsNeeded - 1)
            // Example: In best-of-3, if you were down 0-1 and won 2-1
            if (loserWins === winsNeeded - 1) {
                gameStats.comebacks++;
                console.log('🔥 Comeback detected!');
            }
        }

        // Render stats panel
        function renderStats() {
            // Update global stats
            document.getElementById('statTotalMatches').textContent = gameStats.totalMatches;
            document.getElementById('statTotalRolls').textContent = gameStats.totalRolls;
            document.getElementById('stat-comebacks').textContent = gameStats.comebacks;
            document.getElementById('statTournamentWins').textContent = gameStats.tournamentWins;
            document.getElementById('statSuddenDeathMatches').textContent = gameStats.suddenDeathMatches;  // NEW
            document.getElementById('statTotalTies').textContent = gameStats.totalTies;  // NEW
            
            // Render player stats
            const playerList = document.getElementById('playerStatsList');
            
            // Sort players by wins (descending)
            const sortedPlayers = Object.entries(gameStats.playerWins)
                .sort((a, b) => b[1] - a[1]);
            
            if (sortedPlayers.length === 0) {
                playerList.innerHTML = '<div style="text-align: center; color: #aaa; padding: 20px;">No match wins yet</div>';
                return;
            }
            
            let html = '';
            sortedPlayers.forEach(([playerName, wins]) => {
                // Find player data for color
                const player = players.find(p => p.name === playerName);
                const color = player ? player.color : '#888';
                const initials = player ? player.initials : playerName.substring(0, 2).toUpperCase();
                
                html += `<div class="player-stat-item">`;
                html += `
                    <div class="player-stat-avatar" style="border-color: ${color}">
                        <img src="${getPlayerNFTUrl(player ? player.riderId : 1)}" alt="${playerName}">
                    </div>
                `;
                html += `<div class="player-stat-info">`;
                html += `<div class="player-stat-name">${playerName}</div>`;
                html += `<div class="player-stat-details">${wins} match ${wins === 1 ? 'win' : 'wins'}</div>`;
                html += `</div>`;
                html += `<div class="player-stat-wins">${wins}</div>`;
                html += `</div>`;
            });
            
            playerList.innerHTML = html;
        }

        // Reset all stats
        function resetStats() {
            if (!confirm('Are you sure you want to reset ALL statistics? This cannot be undone!')) {
                return;
            }
            
            gameStats = {
                totalMatches: 0,
                totalRolls: 0,
                comebacks: 0,
                tournamentWins: 0,
                suddenDeathMatches: 0,  // NEW
                totalTies: 0,           // NEW
                playerWins: {},
                currentStreak: 0,
                streakPlayer: null
            };
            
            saveStats();
            renderStats();
            
            alert('All stats have been reset!');
        }

        // Load stats on page load
        loadStats();

        // ====
        // MATCH REPLAY SYSTEM
        // ====

        let replayMode = false;
        let replayIndex = 0;
        let replayHistory = [];
        let replayFullHistory = []; // ✅ NEW: Stores all events (rolls + boosts)

        // ✅ NEW: Add event to replay history
        function addToReplayHistory(type, data) {
            const match = matches[currentMatchIndex];
            if (!match) return;
            
            const event = {
                type: type, // 'roll' or 'boost'
                data: data,
                timestamp: Date.now(),
                round: currentRound,
                matchIndex: currentMatchIndex
            };
            
            replayFullHistory.push(event);
            console.log(`Added ${type} event to replay history:`, event);
        }

        // ✅ NEW: Clear replay history when match changes
        function clearReplayHistory() {
            replayFullHistory = [];
            replayHistory = [];
            replayIndex = 0;
            console.log('Cleared replay history');
        }

        // Exit replay mode
        function exitReplay() {
            replayMode = false;
            replayHistory = [];
            replayIndex = 0;
            
            // Hide replay controls
            document.getElementById('replayControls').classList.remove('active');
            document.body.classList.remove('replay-mode');

            const match = matches[currentMatchIndex];

            // If replay was launched from match-end splash, return there (do NOT advance match)
            if (replayReturnTarget === 'end_splash' && match && match.winner) {
                replayReturnTarget = null;
                // IMPORTANT: pass the winner object to match the function signature
                showMatchEndSplash(match.winner);
                return;
            }
            replayReturnTarget = null;
            
            // ✅ FORCE FULL RE-RENDER OF CURRENT MATCH STATE
            
            // Restore dice display
            if (match && match.scores.length > 0) {
                const lastScore = match.scores[match.scores.length - 1];
                document.getElementById('die1').textContent = lastScore.roll1 || '?';
                document.getElementById('die2').textContent = lastScore.roll2 || '?';
            } else {
                document.getElementById('die1').textContent = '?';
                document.getElementById('die2').textContent = '?';
            }
            
            // Restore result message
            const resultMsg = document.getElementById('resultMessage');
            if (match && match.winner) {
                resultMsg.textContent = `${match.winner.name} wins the match!`;
            } else if (match) {
                const p1Wins = match.scores.filter(s => s.winner === 1).length;
                const p2Wins = match.scores.filter(s => s.winner === 2).length;
                const totalRounds = match.scores.length;
                const inSuddenDeath = totalRounds >= match.bestOf && p1Wins === p2Wins;
                
                if (inSuddenDeath) {
                    resultMsg.innerHTML = `<span class="sudden-death-indicator">⚡ SUDDEN DEATH ⚡</span><br>Next score wins!`;
                } else if (match.scores.length > 0) {
                    const lastScore = match.scores[match.scores.length - 1];
                    if (lastScore.result === 'tie') {
                        resultMsg.textContent = "It's a tie!";
                    } else {
                        const winner = lastScore.winner === 1 ? match.player1 : match.player2;
                        resultMsg.textContent = `${winner.name} wins this round!`;
                    }
                } else {
                    resultMsg.textContent = '';
                }
            } else {
                resultMsg.textContent = '';
            }
            
            // ✅ FORCE FULL BRACKET RE-RENDER
            renderBracket();
            updateMatchInfo();
            
            console.log('Exited replay mode and restored match state');
        }

        // Enter replay mode
        function enterReplayMode() {
            const match = matches[currentMatchIndex];
            
            // Check if there are any events to replay
            if (!match || replayFullHistory.length === 0) {
                alert('No events to replay in this match!');
                return;
            }
            
            // Enter replay mode
            replayMode = true;
            replayHistory = [...replayFullHistory]; // Copy full history
            replayIndex = 0; // ✅ START AT FIRST EVENT (not last)

            // Show replay controls
            document.getElementById('replayControls').classList.add('active');
            document.body.classList.add('replay-mode');

            // Setup slider
            const slider = document.getElementById('replaySlider');
            slider.max = replayHistory.length - 1;
            slider.value = 0; // ✅ Start at first event
            
            // ✅ FIX: Remove old listeners before adding new ones
            slider.onchange = null;
            slider.oninput = null;

            // Add slider event listener
            slider.onchange = function() {
                replayIndex = parseInt(this.value);
                updateReplayView();
            };

            slider.oninput = function() {
                replayIndex = parseInt(this.value);
                updateReplayView();
            };
            
            // Check if match went to sudden death
            const totalRounds = match.scores.length;
            const isSuddenDeath = totalRounds > match.bestOf;
            
            // Add sudden death styling if applicable
            const replayControls = document.getElementById('replayControls');
            if (isSuddenDeath) {
                replayControls.classList.add('sudden-death');
                document.getElementById('replayInfo').innerHTML = 
                    'Viewing Event 1 of ' + replayHistory.length + 
                    ' <span class="replay-sudden-death-badge">⚡ SUDDEN DEATH</span>';
            } else {
                replayControls.classList.remove('sudden-death');
            }
            
            // Start at first event
            updateReplayView();
            
            console.log('Entered replay mode with', replayHistory.length, 'events');
        }

        // Step through replay
        function replayStep(direction) {
            replayIndex += direction;
            
            // Clamp to valid range
            if (replayIndex < 0) replayIndex = 0;
            if (replayIndex >= replayHistory.length) replayIndex = replayHistory.length - 1;
            
            // Update slider
            document.getElementById('replaySlider').value = replayIndex;
            
            updateReplayView();
        }

        // Update replay view
        function updateReplayView() {
            const match = matches[currentMatchIndex];
            const currentEvent = replayHistory[replayIndex];
            
            // Update info text
            const totalEvents = replayHistory.length;
            const eventNumber = replayIndex + 1;
            document.getElementById('replayInfo').textContent = `Viewing Event ${eventNumber} of ${totalEvents}`;
            document.getElementById('replayPosition').textContent = `${eventNumber} / ${totalEvents}`;
            
            // Update button states
            document.getElementById('replayPrev').disabled = replayIndex === 0;
            document.getElementById('replayNext').disabled = replayIndex === replayHistory.length - 1;
            
            // Calculate scores up to this point (only count roll events)
            const eventsUpToNow = replayHistory.slice(0, replayIndex + 1);
            const rollEvents = eventsUpToNow.filter(e => e.type === 'roll');
            const p1Wins = rollEvents.filter(e => e.data.winner === 1).length;
            const p2Wins = rollEvents.filter(e => e.data.winner === 2).length;
            
            // Update display based on event type
            const resultMsg = document.getElementById('resultMessage');
            
            if (currentEvent.type === 'boost') {
                // ✅ Boost activation event
                document.getElementById('die1').textContent = '⚡';
                document.getElementById('die2').textContent = '⚡';
                resultMsg.textContent = currentEvent.data.message;
            } else if (currentEvent.type === 'roll') {
                // ✅ Roll event
                const rollData = currentEvent.data;
                
                // ✅ NEW: Check for special boost results (NosDemon, Guardian)
                if (rollData.result === 'nosdemon') {
                    // NosDemon: Show 0-0 with icon
                    document.getElementById('die1').textContent = '0';
                    document.getElementById('die2').textContent = '0';
                    const winner = rollData.winner === 1 ? match.player1 : match.player2;
                    resultMsg.innerHTML = `⚡ <strong>NOSDEMON</strong> ⚡<br>${winner.name} starts with 1-0 lead!`;
                } else if (rollData.result === 'guardian') {
                    // Guardian: Show 0-0 with icon
                    document.getElementById('die1').textContent = '0';
                    document.getElementById('die2').textContent = '0';
                    const winner = rollData.winner === 1 ? match.player1 : match.player2;
                    resultMsg.innerHTML = `🛡️ <strong>GUARDIAN</strong> 🛡️<br>${winner.name} auto-wins this round!`;
                } else {
                    // Normal roll
                    document.getElementById('die1').textContent = rollData.roll1;
                    document.getElementById('die2').textContent = rollData.roll2;
                    
                    // Update result message
                    if (rollData.result === 'tie') {
                        resultMsg.textContent = "It's a tie!";
                    } else {
                        const winner = rollData.winner === 1 ? match.player1 : match.player2;
                        resultMsg.textContent = `${winner.name} wins this round!`;
                    }
                }
            }
            
            // ✅ SAVE FULL VISUAL STATE BEFORE MODIFYING
            const originalScores = match.scores;
            const originalWinner = match.winner;
            const originalDie1 = document.getElementById('die1').textContent;
            const originalDie2 = document.getElementById('die2').textContent;
            const originalResultMsg = document.getElementById('resultMessage').textContent;

            // Temporarily modify match scores for rendering (only roll events)
            match.scores = rollEvents.map(e => e.data);
            match.winner = null; // Clear winner to prevent showing final state

            // Re-render bracket with replay state
            renderBracket();

            // ✅ IMMEDIATELY RESTORE ORIGINAL STATE (don't wait)
            match.scores = originalScores;
            match.winner = originalWinner;
            
            // ✅ NEW: Check if we're in sudden death during replay
            const totalRollsUpToNow = rollEvents.length;
            const inSuddenDeath = totalRollsUpToNow > match.bestOf && p1Wins === p2Wins;

            // Update match info with replay scores
            const info = document.getElementById('matchInfo');
            if (inSuddenDeath) {
                info.innerHTML = `<span class="sudden-death-indicator">⚡ SUDDEN DEATH ⚡</span><br>REPLAY - Round ${currentRound} - Match ${currentMatchIndex + 1} | Score: ${p1Wins}-${p2Wins}`;
            } else {
                info.textContent = `REPLAY - Round ${currentRound} - Match ${currentMatchIndex + 1} | Score: ${p1Wins}-${p2Wins}`;
            }
            
            // Restore original scores
            match.scores = originalScores;
        }

        // Add keyboard shortcut for replay
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in inputs
            if (document.activeElement.tagName === 'INPUT' || 
                document.activeElement.tagName === 'SELECT' ||
                document.activeElement.tagName === 'TEXTAREA') {
                return;
            }
            
            const key = e.key.toLowerCase();
            
            // Replay mode controls
            if (replayMode) {
                if (key === 'arrowleft') {
                    e.preventDefault();
                    replayStep(-1);
                } else if (key === 'arrowright') {
                    e.preventDefault();
                    replayStep(1);
                } else if (key === 'escape') {
                    exitReplay();
                }
            } else {
                // Enter replay mode with 'P' key
                if (key === 'r') {
                    enterReplayMode();
                }
            }
        });

        // ==== 
        // WINNER EFFECTS SYSTEM
        // ====

        function triggerWinnerEffects(winnerPlayer, winnerElement) {
            console.log('Triggering winner effects for:', winnerPlayer.name);
            
            // 1. Screen Flash
            createScreenFlash(winnerPlayer.color);
            
            // 2. Confetti Burst
            createConfetti(winnerElement, winnerPlayer.color);
            
            // 3. Winner Card Animation
            winnerElement.classList.add('winner-celebration');
            setTimeout(() => {
                winnerElement.classList.remove('winner-celebration');
            }, 800);
            
            // 4. Trophy Icon
            createTrophyIcon(winnerElement);
            
            // 5. Particle Burst
            createParticleBurst(winnerElement, winnerPlayer.color);
            
            // 6. Play Win Sound
            playWinSound();
        }

        // Screen flash effect
        function createScreenFlash(color) {
            const flash = document.createElement('div');
            flash.className = 'screen-flash';
            flash.style.background = `radial-gradient(circle, ${color} 0%, transparent 70%)`;
            document.body.appendChild(flash);
            
            setTimeout(() => {
                document.body.removeChild(flash);
            }, 600);
        }

        // Confetti particles - 360° burst
        function createConfetti(sourceElement, color) {
            const rect = sourceElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Create 40 confetti particles
            for (let i = 0; i < 40; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti-particle';
                confetti.style.left = centerX + 'px';
                confetti.style.top = centerY + 'px';
                confetti.style.background = i % 2 === 0 ? color : '#ffd700';
                
                // Calculate 360° burst direction
                const angle = (Math.PI * 2 * i) / 40; // Evenly distribute around circle
                const distance = 150 + Math.random() * 100; // Random distance
                const velocityX = Math.cos(angle) * distance;
                const velocityY = Math.sin(angle) * distance;
                
                // Set CSS variables for animation
                confetti.style.setProperty('--vx', velocityX + 'px');
                confetti.style.setProperty('--vy', velocityY + 'px');
                confetti.style.setProperty('--rotation', (Math.random() * 720 - 360) + 'deg');
                
                // Random timing
                confetti.style.animationDelay = (Math.random() * 0.2) + 's';
                confetti.style.animationDuration = (1 + Math.random() * 0.5) + 's';
                
                document.body.appendChild(confetti);
                
                setTimeout(() => {
                    if (document.body.contains(confetti)) {
                        document.body.removeChild(confetti);
                    }
                }, 2000);
            }
        }

        // Trophy icon
        function createTrophyIcon(sourceElement) {
            const trophy = document.createElement('div');
            trophy.className = 'winner-trophy';
            trophy.textContent = '🏆';
            sourceElement.style.position = 'relative';
            sourceElement.appendChild(trophy);
            
            setTimeout(() => {
                sourceElement.removeChild(trophy);
            }, 1000);
        }

        // Particle burst
        function createParticleBurst(sourceElement, color) {
            const rect = sourceElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Create 20 particles
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle-burst';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.background = color;
                
                // Random direction
                const angle = (Math.PI * 2 * i) / 20;
                const distance = 100 + Math.random() * 50;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;
                
                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');
                particle.style.animation = `particleBurst ${0.6 + Math.random() * 0.4}s ease-out forwards`;
                
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    document.body.removeChild(particle);
                }, 1000);
            }
        }
        
    </script>

    <!-- ROLL HISTORY TOGGLE BUTTON -->
    <button id="rollHistoryToggle" onclick="toggleRollHistory()">📜 ROLL HISTORY (H)</button>

    <!-- Keyboard Help Button -->
    <button id="keyboardHelpButton" onclick="toggleKeyboardHelp()" style="position: fixed; bottom: 20px; right: 20px; background: rgba(0, 212, 255, 0.2); border: 2px solid #00d4ff; color: #00d4ff; padding: 12px 20px; border-radius: 50px; cursor: pointer; font-size: 14px; font-weight: bold; z-index: 9999; transition: all 0.3s; box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);">
        ⌨️ Shortcuts (?)
    </button>

    <!-- TEST MODE TOGGLE BUTTON -->
    <button id="testModeToggle" onclick="toggleTestMode()">🧪 TEST MODE (T)</button>

    <!-- TEST MODE PANEL -->
    <div id="testModePanel">
        <h2>🧪 TEST MODE</h2>

        <!-- Boost Assignment -->
        <div class="test-section">
            <h3>⚡ Boost Assignment</h3>
            <div class="test-control">
                <label>Select Player:</label>
                <select id="testPlayerSelect">
                    <option value="0">Player 1</option>
                    <option value="1">Player 2</option>
                    <option value="2">Player 3</option>
                    <option value="3">Player 4</option>
                    <option value="4">Player 5</option>
                    <option value="5">Player 6</option>
                    <option value="6">Player 7</option>
                    <option value="7">Player 8</option>
                </select>
            </div>
            <div class="test-control">
                <label>Primary Boost:</label>
                <select id="testPrimaryBoost">
                    <option value="none">None</option>
                    <option value="brawler">Brawler</option>
                    <option value="guardian">Guardian</option>
                    <option value="nosdemon">NosDemon</option>
                    <option value="revive">Revive</option>
                    <option value="thief">Thief</option>
                </select>
            </div>
            <div class="test-control">
                <label>Secondary Boost:</label>
                <select id="testSecondaryBoost">
                    <option value="none">None</option>
                    <option value="saboteur">Saboteur</option>
                    <option value="doubleplay">Double Play</option>
                </select>
            </div>
            <div class="test-control">
                <label>Active In:</label>
                <select id="testRoundRestriction">
                    <option value="any">Any Round</option>
                    <option value="round1">Round 1 Only</option>
                    <option value="round2">Round 2 Only</option>
                    <option value="finals">Finals Only</option>
                </select>
            </div>
            <button class="test-button success" onclick="applyBoostAssignment()">Apply Boosts</button>
        </div>

        <!-- Round Control -->
        <div class="test-section">
            <h3>🎯 Round Control</h3>
            <button class="test-button" onclick="skipToRound(2)">Skip to Round 2</button>
            <button class="test-button" onclick="skipToRound(3)">Skip to Finals</button>
        </div>

        <!-- Interference Control -->
        <div class="test-section">
            <h3>⚠️ Interference Control</h3>
            <button class="test-button" onclick="forceDecryptor()">Force Decryptor (Current Match)</button>
            <button class="test-button" onclick="forceCosmicStorm()">Force Cosmic Storm (Current Match)</button>
            <button class="test-button danger" onclick="clearInterference()">Clear All Interference</button>
        </div>

        <!-- Match Control -->
        <div class="test-section">
            <h3>🎲 Match Control</h3>
            <div class="test-control">
                <label>Set Score (P1-P2 or P1-P2-Ties):</label>
                <input type="text" id="testScore" placeholder="e.g., 2-1 or 2-2-1">
            </div>
            <button class="test-button" onclick="setMatchScore()">Set Score</button>
            <button class="test-button danger" onclick="resetCurrentMatch()">Reset Current Match</button>
        </div>

        <!-- Export -->
        <div class="test-section">
            <h3>📥 Export</h3>
            <button class="test-button" onclick="exportMatch()">Export Match</button>
            <button class="test-button" onclick="exportTournament()">Export Tournament</button>
        </div>

        <!-- Quick Actions -->
        <div class="test-section">
            <h3>⚡ Quick Actions</h3>
            <button class="test-button danger" onclick="resetTournament()">Reset Tournament</button>
            <button class="test-button" onclick="toggleTestMode()">Close Test Mode</button>
        </div>
    </div>





    <!-- ROLL HISTORY PANEL -->
    <div id="rollHistoryPanel">
        <div class="roll-history-title">📜 ROLL HISTORY</div>
        <div class="roll-history-list" id="rollHistoryList">
            <!-- Roll history items will be added here -->
        </div>
    </div>

    <!-- STATS TOGGLE BUTTON -->
    <button id="statsToggle" onclick="toggleStats()">📊 STATS (S)</button>

    <!-- STATS PANEL -->
    <div id="statsPanel">
        <div class="stats-title">📊 TOURNAMENT STATISTICS</div>
        
        <!-- Global Stats -->
        <div class="stats-section">
            <div class="stats-section-title">🌐 Global Stats</div>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="statTotalMatches">0</div>
                    <div class="stat-label">Total Matches</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statTotalRolls">0</div>
                    <div class="stat-label">Total Rolls</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-comebacks">0</div>
                    <div class="stat-label">COMEBACKS</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statTournamentWins">0</div>
                    <div class="stat-label">Tournament Wins</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statSuddenDeathMatches">0</div>
                    <div class="stat-label">Sudden Death Matches</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statTotalTies">0</div>
                    <div class="stat-label">Ties</div>
                </div>
            </div>
        </div>
        
        <!-- Player Stats -->
        <div class="stats-section">
            <div class="stats-section-title">👥 Player Match Wins</div>
            <div class="player-stats-list" id="playerStatsList">
                <!-- Player stats will be rendered here -->
            </div>
        </div>
        
        <!-- Actions -->
        <div class="stats-actions">
            <button class="stats-button" onclick="toggleStats()">Close</button>
            <button class="stats-button danger" onclick="resetStats()">Reset All Stats</button>
        </div>
    </div>

    <!-- MATCH REPLAY CONTROLS -->
    <div id="replayControls">
        <div class="replay-banner">🎬 REPLAY MODE</div>
        <div class="replay-info" id="replayInfo">Viewing Roll 1 of 5</div>
        
        <div class="replay-slider-container">
            <div class="replay-position" id="replayPosition">1 / 5</div>
            <input type="range" class="replay-slider" id="replaySlider" min="0" max="0" value="0">
        </div>
        
        <div class="replay-buttons">
            <button class="replay-btn" id="replayPrev" onclick="replayStep(-1)">← Previous</button>
            <button class="replay-btn exit" id="replayExit" onclick="exitReplay()">Exit Replay (ESC)</button>
            <button class="replay-btn" id="replayNext" onclick="replayStep(1)">Next →</button>
        </div>
    </div>

</body>
</html>
